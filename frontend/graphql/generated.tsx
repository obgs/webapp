import { gql } from "@apollo/client";
import * as Apollo from "@apollo/client";
import {
  GraphQLResolveInfo,
  GraphQLScalarType,
  GraphQLScalarTypeConfig,
} from "graphql";
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = {
  [K in keyof T]: T[K];
};
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]?: Maybe<T[SubKey]>;
};
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]: Maybe<T[SubKey]>;
};
export type RequireFields<T, K extends keyof T> = Omit<T, K> & {
  [P in K]-?: NonNullable<T[P]>;
};
const defaultOptions = {} as const;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  Cursor: any;
  Time: any;
};

/** This type is exposed for type safety on client side */
export type AggregateMetadata = {
  __typename?: "AggregateMetadata";
  statIds: Array<Scalars["ID"]>;
  type: AggregateMetadataType;
};

export type AggregateMetadataInput = {
  statOrderNumbers: Array<Scalars["Int"]>;
  type: AggregateMetadataType;
};

export enum AggregateMetadataType {
  /** Sum of all values */
  Sum = "sum",
}

export type CreateGameInput = {
  boardgamegeekURL?: InputMaybe<Scalars["String"]>;
  description?: InputMaybe<Scalars["String"]>;
  maxPlayers: Scalars["Int"];
  minPlayers: Scalars["Int"];
  name: Scalars["String"];
  statDescriptions: Array<StatDescriptionInput>;
};

export type CreateMatchInput = {
  gameVersionId: Scalars["ID"];
  playerIds: Array<Scalars["ID"]>;
  stats: Array<StatInput>;
};

export type CreateOrUpdateGroupInput = {
  description?: InputMaybe<Scalars["String"]>;
  id?: InputMaybe<Scalars["ID"]>;
  logoUrl: Scalars["String"];
  name: Scalars["String"];
  settings: GroupSettingsInput;
};

export type CreatePlayerInput = {
  name: Scalars["String"];
};

/** This type is exposed for type safety on client side */
export type EnumMetadata = {
  __typename?: "EnumMetadata";
  possibleValues: Array<Scalars["String"]>;
};

export type EnumMetadataInput = {
  possibleValues: Array<Scalars["String"]>;
};

export type EnumMetric = {
  __typename?: "EnumMetric";
  global: Array<EnumOccurences>;
  stat: StatDescription;
  user?: Maybe<Array<EnumOccurences>>;
};

export type EnumOccurences = {
  __typename?: "EnumOccurences";
  occurences: Scalars["Int"];
  value: Scalars["String"];
};

export type Favorites = {
  __typename?: "Favorites";
  total: Scalars["Int"];
  users: Array<User>;
};

export type Game = Node & {
  __typename?: "Game";
  author: User;
  boardgamegeekURL?: Maybe<Scalars["String"]>;
  description?: Maybe<Scalars["String"]>;
  favorites: Favorites;
  id: Scalars["ID"];
  /** Whether the current user has favorited this game */
  isFavorite: Scalars["Boolean"];
  maxPlayers: Scalars["Int"];
  minPlayers: Scalars["Int"];
  name: Scalars["String"];
  versions: Array<GameVersion>;
};

/** A connection to a list of items. */
export type GameConnection = {
  __typename?: "GameConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GameEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"];
};

/** An edge in a connection. */
export type GameEdge = {
  __typename?: "GameEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["Cursor"];
  /** The item at the end of the edge. */
  node?: Maybe<Game>;
};

export type GameVersion = Node & {
  __typename?: "GameVersion";
  game: Game;
  id: Scalars["ID"];
  metrics: GameVersionMetrics;
  statDescriptions: Array<StatDescription>;
  versionNumber: Scalars["Int"];
};

export type GameVersionMetrics = {
  __typename?: "GameVersionMetrics";
  adoption: TimeFloatMetric;
  enumStats: Array<EnumMetric>;
  matchesCreated: TimeSeries;
  numericStats: Array<NumericMetric>;
};

export type GameVersionMetricsAdoptionArgs = {
  input: GranularityInput;
};

export type GameVersionMetricsMatchesCreatedArgs = {
  input: TimeSeriesInput;
};

/**
 * GameVersionWhereInput is used for filtering GameVersion objects.
 * Input was generated by ent.
 */
export type GameVersionWhereInput = {
  and?: InputMaybe<Array<GameVersionWhereInput>>;
  /** game edge predicates */
  hasGame?: InputMaybe<Scalars["Boolean"]>;
  hasGameWith?: InputMaybe<Array<GameWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars["ID"]>;
  idGT?: InputMaybe<Scalars["ID"]>;
  idGTE?: InputMaybe<Scalars["ID"]>;
  idIn?: InputMaybe<Array<Scalars["ID"]>>;
  idLT?: InputMaybe<Scalars["ID"]>;
  idLTE?: InputMaybe<Scalars["ID"]>;
  idNEQ?: InputMaybe<Scalars["ID"]>;
  idNotIn?: InputMaybe<Array<Scalars["ID"]>>;
  not?: InputMaybe<GameVersionWhereInput>;
  or?: InputMaybe<Array<GameVersionWhereInput>>;
  /** version_number field predicates */
  versionNumber?: InputMaybe<Scalars["Int"]>;
  versionNumberGT?: InputMaybe<Scalars["Int"]>;
  versionNumberGTE?: InputMaybe<Scalars["Int"]>;
  versionNumberIn?: InputMaybe<Array<Scalars["Int"]>>;
  versionNumberLT?: InputMaybe<Scalars["Int"]>;
  versionNumberLTE?: InputMaybe<Scalars["Int"]>;
  versionNumberNEQ?: InputMaybe<Scalars["Int"]>;
  versionNumberNotIn?: InputMaybe<Array<Scalars["Int"]>>;
};

/**
 * GameWhereInput is used for filtering Game objects.
 * Input was generated by ent.
 */
export type GameWhereInput = {
  and?: InputMaybe<Array<GameWhereInput>>;
  /** author edge predicates */
  hasAuthor?: InputMaybe<Scalars["Boolean"]>;
  hasAuthorWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars["ID"]>;
  idGT?: InputMaybe<Scalars["ID"]>;
  idGTE?: InputMaybe<Scalars["ID"]>;
  idIn?: InputMaybe<Array<Scalars["ID"]>>;
  idLT?: InputMaybe<Scalars["ID"]>;
  idLTE?: InputMaybe<Scalars["ID"]>;
  idNEQ?: InputMaybe<Scalars["ID"]>;
  idNotIn?: InputMaybe<Array<Scalars["ID"]>>;
  /** max_players field predicates */
  maxPlayers?: InputMaybe<Scalars["Int"]>;
  maxPlayersGT?: InputMaybe<Scalars["Int"]>;
  maxPlayersGTE?: InputMaybe<Scalars["Int"]>;
  maxPlayersIn?: InputMaybe<Array<Scalars["Int"]>>;
  maxPlayersLT?: InputMaybe<Scalars["Int"]>;
  maxPlayersLTE?: InputMaybe<Scalars["Int"]>;
  maxPlayersNEQ?: InputMaybe<Scalars["Int"]>;
  maxPlayersNotIn?: InputMaybe<Array<Scalars["Int"]>>;
  /** min_players field predicates */
  minPlayers?: InputMaybe<Scalars["Int"]>;
  minPlayersGT?: InputMaybe<Scalars["Int"]>;
  minPlayersGTE?: InputMaybe<Scalars["Int"]>;
  minPlayersIn?: InputMaybe<Array<Scalars["Int"]>>;
  minPlayersLT?: InputMaybe<Scalars["Int"]>;
  minPlayersLTE?: InputMaybe<Scalars["Int"]>;
  minPlayersNEQ?: InputMaybe<Scalars["Int"]>;
  minPlayersNotIn?: InputMaybe<Array<Scalars["Int"]>>;
  /** name field predicates */
  name?: InputMaybe<Scalars["String"]>;
  nameContains?: InputMaybe<Scalars["String"]>;
  nameContainsFold?: InputMaybe<Scalars["String"]>;
  nameEqualFold?: InputMaybe<Scalars["String"]>;
  nameGT?: InputMaybe<Scalars["String"]>;
  nameGTE?: InputMaybe<Scalars["String"]>;
  nameHasPrefix?: InputMaybe<Scalars["String"]>;
  nameHasSuffix?: InputMaybe<Scalars["String"]>;
  nameIn?: InputMaybe<Array<Scalars["String"]>>;
  nameLT?: InputMaybe<Scalars["String"]>;
  nameLTE?: InputMaybe<Scalars["String"]>;
  nameNEQ?: InputMaybe<Scalars["String"]>;
  nameNotIn?: InputMaybe<Array<Scalars["String"]>>;
  not?: InputMaybe<GameWhereInput>;
  or?: InputMaybe<Array<GameWhereInput>>;
};

export enum Granularity {
  Day = "DAY",
  Month = "MONTH",
  Week = "WEEK",
  Year = "YEAR",
}

export type GranularityInput = {
  value: Granularity;
};

export type Group = Node & {
  __typename?: "Group";
  applications?: Maybe<Array<GroupMembershipApplication>>;
  /** Shows if the current user already applied to the group */
  applied?: Maybe<Scalars["Boolean"]>;
  description: Scalars["String"];
  id: Scalars["ID"];
  logoURL: Scalars["String"];
  members: GroupMembershipConnection;
  name: Scalars["String"];
  /** Role of the current user in the group */
  role?: Maybe<GroupMembershipRole>;
  settings: GroupSettings;
};

export type GroupMembersArgs = {
  after?: InputMaybe<Scalars["Cursor"]>;
  before?: InputMaybe<Scalars["Cursor"]>;
  first?: InputMaybe<Scalars["Int"]>;
  last?: InputMaybe<Scalars["Int"]>;
  where?: InputMaybe<GroupMembershipWhereInput>;
};

export type GroupApplicationInput = {
  groupId: Scalars["ID"];
  message?: InputMaybe<Scalars["String"]>;
};

/** A connection to a list of items. */
export type GroupConnection = {
  __typename?: "GroupConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GroupEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"];
};

/** An edge in a connection. */
export type GroupEdge = {
  __typename?: "GroupEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["Cursor"];
  /** The item at the end of the edge. */
  node?: Maybe<Group>;
};

export type GroupMembership = Node & {
  __typename?: "GroupMembership";
  group: Group;
  id: Scalars["ID"];
  role: GroupMembershipRole;
  user: User;
};

export type GroupMembershipApplication = Node & {
  __typename?: "GroupMembershipApplication";
  group: Group;
  id: Scalars["ID"];
  message: Scalars["String"];
  user: User;
};

/** A connection to a list of items. */
export type GroupMembershipConnection = {
  __typename?: "GroupMembershipConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GroupMembershipEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"];
};

/** An edge in a connection. */
export type GroupMembershipEdge = {
  __typename?: "GroupMembershipEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["Cursor"];
  /** The item at the end of the edge. */
  node?: Maybe<GroupMembership>;
};

/** GroupMembershipRole is enum for the field role */
export enum GroupMembershipRole {
  Admin = "admin",
  Member = "member",
  Owner = "owner",
}

/**
 * GroupMembershipWhereInput is used for filtering GroupMembership objects.
 * Input was generated by ent.
 */
export type GroupMembershipWhereInput = {
  and?: InputMaybe<Array<GroupMembershipWhereInput>>;
  /** group edge predicates */
  hasGroup?: InputMaybe<Scalars["Boolean"]>;
  hasGroupWith?: InputMaybe<Array<GroupWhereInput>>;
  /** user edge predicates */
  hasUser?: InputMaybe<Scalars["Boolean"]>;
  hasUserWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars["ID"]>;
  idGT?: InputMaybe<Scalars["ID"]>;
  idGTE?: InputMaybe<Scalars["ID"]>;
  idIn?: InputMaybe<Array<Scalars["ID"]>>;
  idLT?: InputMaybe<Scalars["ID"]>;
  idLTE?: InputMaybe<Scalars["ID"]>;
  idNEQ?: InputMaybe<Scalars["ID"]>;
  idNotIn?: InputMaybe<Array<Scalars["ID"]>>;
  not?: InputMaybe<GroupMembershipWhereInput>;
  or?: InputMaybe<Array<GroupMembershipWhereInput>>;
  /** role field predicates */
  role?: InputMaybe<GroupMembershipRole>;
  roleIn?: InputMaybe<Array<GroupMembershipRole>>;
  roleNEQ?: InputMaybe<GroupMembershipRole>;
  roleNotIn?: InputMaybe<Array<GroupMembershipRole>>;
};

export type GroupSettings = Node & {
  __typename?: "GroupSettings";
  id: Scalars["ID"];
  joinPolicy: GroupSettingsJoinPolicy;
  minimumRoleToInvite?: Maybe<GroupMembershipRole>;
  visibility: GroupSettingsVisibility;
};

export type GroupSettingsInput = {
  joinPolicy: GroupSettingsJoinPolicy;
  minimumRoleToInvite?: InputMaybe<GroupMembershipRole>;
  visibility: GroupSettingsVisibility;
};

/** GroupSettingsJoinPolicy is enum for the field join_policy */
export enum GroupSettingsJoinPolicy {
  ApplicationOnly = "APPLICATION_ONLY",
  InviteOnly = "INVITE_ONLY",
  InviteOrApplication = "INVITE_OR_APPLICATION",
  Open = "OPEN",
}

/** GroupSettingsVisibility is enum for the field visibility */
export enum GroupSettingsVisibility {
  Private = "PRIVATE",
  Public = "PUBLIC",
}

/**
 * GroupSettingsWhereInput is used for filtering GroupSettings objects.
 * Input was generated by ent.
 */
export type GroupSettingsWhereInput = {
  and?: InputMaybe<Array<GroupSettingsWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars["ID"]>;
  idGT?: InputMaybe<Scalars["ID"]>;
  idGTE?: InputMaybe<Scalars["ID"]>;
  idIn?: InputMaybe<Array<Scalars["ID"]>>;
  idLT?: InputMaybe<Scalars["ID"]>;
  idLTE?: InputMaybe<Scalars["ID"]>;
  idNEQ?: InputMaybe<Scalars["ID"]>;
  idNotIn?: InputMaybe<Array<Scalars["ID"]>>;
  /** join_policy field predicates */
  joinPolicy?: InputMaybe<GroupSettingsJoinPolicy>;
  joinPolicyIn?: InputMaybe<Array<GroupSettingsJoinPolicy>>;
  joinPolicyNEQ?: InputMaybe<GroupSettingsJoinPolicy>;
  joinPolicyNotIn?: InputMaybe<Array<GroupSettingsJoinPolicy>>;
  not?: InputMaybe<GroupSettingsWhereInput>;
  or?: InputMaybe<Array<GroupSettingsWhereInput>>;
  /** visibility field predicates */
  visibility?: InputMaybe<GroupSettingsVisibility>;
  visibilityIn?: InputMaybe<Array<GroupSettingsVisibility>>;
  visibilityNEQ?: InputMaybe<GroupSettingsVisibility>;
  visibilityNotIn?: InputMaybe<Array<GroupSettingsVisibility>>;
};

/**
 * GroupWhereInput is used for filtering Group objects.
 * Input was generated by ent.
 */
export type GroupWhereInput = {
  and?: InputMaybe<Array<GroupWhereInput>>;
  /** members edge predicates */
  hasMembers?: InputMaybe<Scalars["Boolean"]>;
  hasMembersWith?: InputMaybe<Array<GroupMembershipWhereInput>>;
  /** settings edge predicates */
  hasSettings?: InputMaybe<Scalars["Boolean"]>;
  hasSettingsWith?: InputMaybe<Array<GroupSettingsWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars["ID"]>;
  idGT?: InputMaybe<Scalars["ID"]>;
  idGTE?: InputMaybe<Scalars["ID"]>;
  idIn?: InputMaybe<Array<Scalars["ID"]>>;
  idLT?: InputMaybe<Scalars["ID"]>;
  idLTE?: InputMaybe<Scalars["ID"]>;
  idNEQ?: InputMaybe<Scalars["ID"]>;
  idNotIn?: InputMaybe<Array<Scalars["ID"]>>;
  /** name field predicates */
  name?: InputMaybe<Scalars["String"]>;
  nameContains?: InputMaybe<Scalars["String"]>;
  nameContainsFold?: InputMaybe<Scalars["String"]>;
  nameEqualFold?: InputMaybe<Scalars["String"]>;
  nameGT?: InputMaybe<Scalars["String"]>;
  nameGTE?: InputMaybe<Scalars["String"]>;
  nameHasPrefix?: InputMaybe<Scalars["String"]>;
  nameHasSuffix?: InputMaybe<Scalars["String"]>;
  nameIn?: InputMaybe<Array<Scalars["String"]>>;
  nameLT?: InputMaybe<Scalars["String"]>;
  nameLTE?: InputMaybe<Scalars["String"]>;
  nameNEQ?: InputMaybe<Scalars["String"]>;
  nameNotIn?: InputMaybe<Array<Scalars["String"]>>;
  not?: InputMaybe<GroupWhereInput>;
  or?: InputMaybe<Array<GroupWhereInput>>;
};

export type Header = {
  __typename?: "Header";
  key: Scalars["String"];
  value: Scalars["String"];
};

export type Match = Node & {
  __typename?: "Match";
  createdAt: Scalars["Time"];
  gameVersion: GameVersion;
  id: Scalars["ID"];
  players: Array<Player>;
  stats?: Maybe<Array<Statistic>>;
};

/** A connection to a list of items. */
export type MatchConnection = {
  __typename?: "MatchConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<MatchEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"];
};

/** An edge in a connection. */
export type MatchEdge = {
  __typename?: "MatchEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["Cursor"];
  /** The item at the end of the edge. */
  node?: Maybe<Match>;
};

/**
 * MatchWhereInput is used for filtering Match objects.
 * Input was generated by ent.
 */
export type MatchWhereInput = {
  and?: InputMaybe<Array<MatchWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars["Time"]>;
  createdAtGT?: InputMaybe<Scalars["Time"]>;
  createdAtGTE?: InputMaybe<Scalars["Time"]>;
  createdAtIn?: InputMaybe<Array<Scalars["Time"]>>;
  createdAtLT?: InputMaybe<Scalars["Time"]>;
  createdAtLTE?: InputMaybe<Scalars["Time"]>;
  createdAtNEQ?: InputMaybe<Scalars["Time"]>;
  createdAtNotIn?: InputMaybe<Array<Scalars["Time"]>>;
  /** game_version edge predicates */
  hasGameVersion?: InputMaybe<Scalars["Boolean"]>;
  hasGameVersionWith?: InputMaybe<Array<GameVersionWhereInput>>;
  /** players edge predicates */
  hasPlayers?: InputMaybe<Scalars["Boolean"]>;
  hasPlayersWith?: InputMaybe<Array<PlayerWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars["ID"]>;
  idGT?: InputMaybe<Scalars["ID"]>;
  idGTE?: InputMaybe<Scalars["ID"]>;
  idIn?: InputMaybe<Array<Scalars["ID"]>>;
  idLT?: InputMaybe<Scalars["ID"]>;
  idLTE?: InputMaybe<Scalars["ID"]>;
  idNEQ?: InputMaybe<Scalars["ID"]>;
  idNotIn?: InputMaybe<Array<Scalars["ID"]>>;
  not?: InputMaybe<MatchWhereInput>;
  or?: InputMaybe<Array<MatchWhereInput>>;
};

export type Mutation = {
  __typename?: "Mutation";
  addOrRemoveGameFromFavorites: Scalars["Boolean"];
  applyToGroup: GroupMembershipApplication;
  changeUserGroupMembershipRole: Scalars["Boolean"];
  createGame: Game;
  createMatch: Match;
  createOrUpdateGroup: Group;
  createPlayer: Player;
  joinGroup: Scalars["Boolean"];
  kickUserFromGroup: Scalars["Boolean"];
  requestPlayerSupervision: PlayerSupervisionRequest;
  resolveGroupMembershipApplication: Scalars["Boolean"];
  resolvePlayerSupervisionRequest: Scalars["Boolean"];
  updateUser: User;
};

export type MutationAddOrRemoveGameFromFavoritesArgs = {
  favorite: Scalars["Boolean"];
  gameId: Scalars["ID"];
};

export type MutationApplyToGroupArgs = {
  input: GroupApplicationInput;
};

export type MutationChangeUserGroupMembershipRoleArgs = {
  groupId: Scalars["ID"];
  role: GroupMembershipRole;
  userId: Scalars["ID"];
};

export type MutationCreateGameArgs = {
  input: CreateGameInput;
};

export type MutationCreateMatchArgs = {
  input: CreateMatchInput;
};

export type MutationCreateOrUpdateGroupArgs = {
  input: CreateOrUpdateGroupInput;
};

export type MutationCreatePlayerArgs = {
  input: CreatePlayerInput;
};

export type MutationJoinGroupArgs = {
  groupId: Scalars["ID"];
};

export type MutationKickUserFromGroupArgs = {
  groupId: Scalars["ID"];
  userId: Scalars["ID"];
};

export type MutationRequestPlayerSupervisionArgs = {
  input?: InputMaybe<RequestPlayerSupervisionInput>;
};

export type MutationResolveGroupMembershipApplicationArgs = {
  accepted: Scalars["Boolean"];
  applicationId: Scalars["ID"];
};

export type MutationResolvePlayerSupervisionRequestArgs = {
  input: ResolvePlayerSupervisionRequestInput;
};

export type MutationUpdateUserArgs = {
  id: Scalars["ID"];
  input: UpdateUserInput;
};

/**
 * An object with an ID.
 * Follows the [Relay Global Object Identification Specification](https://relay.dev/graphql/objectidentification.htm)
 */
export type Node = {
  /** The id of the object. */
  id: Scalars["ID"];
};

export type NumericMetric = {
  __typename?: "NumericMetric";
  globalAverage: Scalars["Float"];
  stat: StatDescription;
  userAverage?: Maybe<Scalars["Float"]>;
};

/** Possible directions in which to order a list of items when provided an `orderBy` argument. */
export enum OrderDirection {
  /** Specifies an ascending order for a given `orderBy` argument. */
  Asc = "ASC",
  /** Specifies a descending order for a given `orderBy` argument. */
  Desc = "DESC",
}

/**
 * Information about pagination in a connection.
 * https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo
 */
export type PageInfo = {
  __typename?: "PageInfo";
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars["Cursor"]>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars["Boolean"];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars["Boolean"];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars["Cursor"]>;
};

export type Player = Node & {
  __typename?: "Player";
  id: Scalars["ID"];
  matches?: Maybe<Array<Match>>;
  name: Scalars["String"];
  owner?: Maybe<User>;
  supervisionRequests?: Maybe<Array<PlayerSupervisionRequest>>;
  supervisors?: Maybe<Array<User>>;
};

/** A connection to a list of items. */
export type PlayerConnection = {
  __typename?: "PlayerConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PlayerEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"];
};

/** An edge in a connection. */
export type PlayerEdge = {
  __typename?: "PlayerEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["Cursor"];
  /** The item at the end of the edge. */
  node?: Maybe<Player>;
};

export type PlayerSupervisionRequest = Node & {
  __typename?: "PlayerSupervisionRequest";
  approvals?: Maybe<Array<PlayerSupervisionRequestApproval>>;
  id: Scalars["ID"];
  message?: Maybe<Scalars["String"]>;
  player: Player;
  sender: User;
};

export type PlayerSupervisionRequestApproval = Node & {
  __typename?: "PlayerSupervisionRequestApproval";
  approved?: Maybe<Scalars["Boolean"]>;
  approver: User;
  id: Scalars["ID"];
  supervisionRequest: PlayerSupervisionRequest;
};

/**
 * PlayerSupervisionRequestApprovalWhereInput is used for filtering PlayerSupervisionRequestApproval objects.
 * Input was generated by ent.
 */
export type PlayerSupervisionRequestApprovalWhereInput = {
  and?: InputMaybe<Array<PlayerSupervisionRequestApprovalWhereInput>>;
  /** approved field predicates */
  approved?: InputMaybe<Scalars["Boolean"]>;
  approvedIsNil?: InputMaybe<Scalars["Boolean"]>;
  approvedNEQ?: InputMaybe<Scalars["Boolean"]>;
  approvedNotNil?: InputMaybe<Scalars["Boolean"]>;
  /** approver edge predicates */
  hasApprover?: InputMaybe<Scalars["Boolean"]>;
  hasApproverWith?: InputMaybe<Array<UserWhereInput>>;
  /** supervision_request edge predicates */
  hasSupervisionRequest?: InputMaybe<Scalars["Boolean"]>;
  hasSupervisionRequestWith?: InputMaybe<
    Array<PlayerSupervisionRequestWhereInput>
  >;
  /** id field predicates */
  id?: InputMaybe<Scalars["ID"]>;
  idGT?: InputMaybe<Scalars["ID"]>;
  idGTE?: InputMaybe<Scalars["ID"]>;
  idIn?: InputMaybe<Array<Scalars["ID"]>>;
  idLT?: InputMaybe<Scalars["ID"]>;
  idLTE?: InputMaybe<Scalars["ID"]>;
  idNEQ?: InputMaybe<Scalars["ID"]>;
  idNotIn?: InputMaybe<Array<Scalars["ID"]>>;
  not?: InputMaybe<PlayerSupervisionRequestApprovalWhereInput>;
  or?: InputMaybe<Array<PlayerSupervisionRequestApprovalWhereInput>>;
};

/**
 * PlayerSupervisionRequestWhereInput is used for filtering PlayerSupervisionRequest objects.
 * Input was generated by ent.
 */
export type PlayerSupervisionRequestWhereInput = {
  and?: InputMaybe<Array<PlayerSupervisionRequestWhereInput>>;
  /** approvals edge predicates */
  hasApprovals?: InputMaybe<Scalars["Boolean"]>;
  hasApprovalsWith?: InputMaybe<
    Array<PlayerSupervisionRequestApprovalWhereInput>
  >;
  /** player edge predicates */
  hasPlayer?: InputMaybe<Scalars["Boolean"]>;
  hasPlayerWith?: InputMaybe<Array<PlayerWhereInput>>;
  /** sender edge predicates */
  hasSender?: InputMaybe<Scalars["Boolean"]>;
  hasSenderWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars["ID"]>;
  idGT?: InputMaybe<Scalars["ID"]>;
  idGTE?: InputMaybe<Scalars["ID"]>;
  idIn?: InputMaybe<Array<Scalars["ID"]>>;
  idLT?: InputMaybe<Scalars["ID"]>;
  idLTE?: InputMaybe<Scalars["ID"]>;
  idNEQ?: InputMaybe<Scalars["ID"]>;
  idNotIn?: InputMaybe<Array<Scalars["ID"]>>;
  not?: InputMaybe<PlayerSupervisionRequestWhereInput>;
  or?: InputMaybe<Array<PlayerSupervisionRequestWhereInput>>;
};

/**
 * PlayerWhereInput is used for filtering Player objects.
 * Input was generated by ent.
 */
export type PlayerWhereInput = {
  and?: InputMaybe<Array<PlayerWhereInput>>;
  /** owner edge predicates */
  hasOwner?: InputMaybe<Scalars["Boolean"]>;
  hasOwnerWith?: InputMaybe<Array<UserWhereInput>>;
  /** supervision_requests edge predicates */
  hasSupervisionRequests?: InputMaybe<Scalars["Boolean"]>;
  hasSupervisionRequestsWith?: InputMaybe<
    Array<PlayerSupervisionRequestWhereInput>
  >;
  /** supervisors edge predicates */
  hasSupervisors?: InputMaybe<Scalars["Boolean"]>;
  hasSupervisorsWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars["ID"]>;
  idGT?: InputMaybe<Scalars["ID"]>;
  idGTE?: InputMaybe<Scalars["ID"]>;
  idIn?: InputMaybe<Array<Scalars["ID"]>>;
  idLT?: InputMaybe<Scalars["ID"]>;
  idLTE?: InputMaybe<Scalars["ID"]>;
  idNEQ?: InputMaybe<Scalars["ID"]>;
  idNotIn?: InputMaybe<Array<Scalars["ID"]>>;
  /** name field predicates */
  name?: InputMaybe<Scalars["String"]>;
  nameContains?: InputMaybe<Scalars["String"]>;
  nameContainsFold?: InputMaybe<Scalars["String"]>;
  nameEqualFold?: InputMaybe<Scalars["String"]>;
  nameGT?: InputMaybe<Scalars["String"]>;
  nameGTE?: InputMaybe<Scalars["String"]>;
  nameHasPrefix?: InputMaybe<Scalars["String"]>;
  nameHasSuffix?: InputMaybe<Scalars["String"]>;
  nameIn?: InputMaybe<Array<Scalars["String"]>>;
  nameLT?: InputMaybe<Scalars["String"]>;
  nameLTE?: InputMaybe<Scalars["String"]>;
  nameNEQ?: InputMaybe<Scalars["String"]>;
  nameNotIn?: InputMaybe<Array<Scalars["String"]>>;
  not?: InputMaybe<PlayerWhereInput>;
  or?: InputMaybe<Array<PlayerWhereInput>>;
};

export type Query = {
  __typename?: "Query";
  games: GameConnection;
  groups: GroupConnection;
  matches: MatchConnection;
  me: User;
  /** Fetches an object given its ID. */
  node?: Maybe<Node>;
  /** Lookup nodes by a list of IDs. */
  nodes: Array<Maybe<Node>>;
  players: PlayerConnection;
  preSignUploadURL: UploadUrl;
  users: UserConnection;
};

export type QueryGamesArgs = {
  after?: InputMaybe<Scalars["Cursor"]>;
  before?: InputMaybe<Scalars["Cursor"]>;
  first?: InputMaybe<Scalars["Int"]>;
  last?: InputMaybe<Scalars["Int"]>;
  where?: InputMaybe<GameWhereInput>;
};

export type QueryGroupsArgs = {
  after?: InputMaybe<Scalars["Cursor"]>;
  before?: InputMaybe<Scalars["Cursor"]>;
  first?: InputMaybe<Scalars["Int"]>;
  last?: InputMaybe<Scalars["Int"]>;
  where?: InputMaybe<GroupWhereInput>;
};

export type QueryMatchesArgs = {
  after?: InputMaybe<Scalars["Cursor"]>;
  before?: InputMaybe<Scalars["Cursor"]>;
  first?: InputMaybe<Scalars["Int"]>;
  last?: InputMaybe<Scalars["Int"]>;
  where?: InputMaybe<MatchWhereInput>;
};

export type QueryNodeArgs = {
  id: Scalars["ID"];
};

export type QueryNodesArgs = {
  ids: Array<Scalars["ID"]>;
};

export type QueryPlayersArgs = {
  after?: InputMaybe<Scalars["Cursor"]>;
  before?: InputMaybe<Scalars["Cursor"]>;
  first?: InputMaybe<Scalars["Int"]>;
  last?: InputMaybe<Scalars["Int"]>;
  where?: InputMaybe<PlayerWhereInput>;
};

export type QueryUsersArgs = {
  after?: InputMaybe<Scalars["Cursor"]>;
  before?: InputMaybe<Scalars["Cursor"]>;
  first?: InputMaybe<Scalars["Int"]>;
  last?: InputMaybe<Scalars["Int"]>;
  where?: InputMaybe<UserWhereInput>;
};

export type RequestPlayerSupervisionInput = {
  message?: InputMaybe<Scalars["String"]>;
  playerId: Scalars["ID"];
};

export type ResolvePlayerSupervisionRequestInput = {
  approved: Scalars["Boolean"];
  requestId: Scalars["ID"];
};

export type StatDescription = Node & {
  __typename?: "StatDescription";
  description?: Maybe<Scalars["String"]>;
  id: Scalars["ID"];
  metadata?: Maybe<Scalars["String"]>;
  name: Scalars["String"];
  orderNumber: Scalars["Int"];
  type: StatDescriptionStatType;
};

export type StatDescriptionInput = {
  description?: InputMaybe<Scalars["String"]>;
  metadata?: InputMaybe<StatMetadataInput>;
  name: Scalars["String"];
  orderNumber: Scalars["Int"];
  type: StatDescriptionStatType;
};

/** StatDescriptionStatType is enum for the field type */
export enum StatDescriptionStatType {
  Aggregate = "aggregate",
  Enum = "enum",
  Numeric = "numeric",
}

export type StatInput = {
  playerId: Scalars["ID"];
  /** The StatDescription ID of the stat to be created */
  statId: Scalars["ID"];
  value: Scalars["String"];
};

export type StatMetadataInput = {
  aggregateMetadata?: InputMaybe<AggregateMetadataInput>;
  /** Once input unions are in graphql, this will be one */
  enumMetadata?: InputMaybe<EnumMetadataInput>;
};

export type Statistic = Node & {
  __typename?: "Statistic";
  id: Scalars["ID"];
  match: Match;
  player: Player;
  statDescription: StatDescription;
  value: Scalars["String"];
};

export type TimeFloatMetric = {
  __typename?: "TimeFloatMetric";
  trend: Scalars["Float"];
  value: Scalars["Float"];
};

export type TimeSeries = {
  __typename?: "TimeSeries";
  series: Array<TimeSeriesPeriod>;
};

export type TimeSeriesInput = {
  end: Scalars["Time"];
  granularity: GranularityInput;
  start: Scalars["Time"];
};

export type TimeSeriesPeriod = {
  __typename?: "TimeSeriesPeriod";
  activityCount: Scalars["Int"];
  end: Scalars["Time"];
  start: Scalars["Time"];
};

/**
 * UpdateUserInput is used for update User object.
 * Input was generated by ent.
 */
export type UpdateUserInput = {
  addPlayerIDs?: InputMaybe<Array<Scalars["ID"]>>;
  avatarURL?: InputMaybe<Scalars["String"]>;
  clearMainPlayer?: InputMaybe<Scalars["Boolean"]>;
  clearPlayers?: InputMaybe<Scalars["Boolean"]>;
  email?: InputMaybe<Scalars["String"]>;
  mainPlayerID?: InputMaybe<Scalars["ID"]>;
  name?: InputMaybe<Scalars["String"]>;
  removePlayerIDs?: InputMaybe<Array<Scalars["ID"]>>;
};

export type UploadUrl = {
  __typename?: "UploadURL";
  headers: Array<Header>;
  url: Scalars["String"];
};

export type User = Node & {
  __typename?: "User";
  avatarURL: Scalars["String"];
  email: Scalars["String"];
  games?: Maybe<Array<Game>>;
  groupMembershipApplications?: Maybe<Array<GroupMembershipApplication>>;
  groupMemberships?: Maybe<Array<GroupMembership>>;
  id: Scalars["ID"];
  mainPlayer?: Maybe<Player>;
  name: Scalars["String"];
  players?: Maybe<Array<Player>>;
  receivedSupervisionRequests: Array<PlayerSupervisionRequest>;
  sentSupervisionRequests: Array<PlayerSupervisionRequest>;
};

/** A connection to a list of items. */
export type UserConnection = {
  __typename?: "UserConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<UserEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"];
};

/** An edge in a connection. */
export type UserEdge = {
  __typename?: "UserEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["Cursor"];
  /** The item at the end of the edge. */
  node?: Maybe<User>;
};

/**
 * UserWhereInput is used for filtering User objects.
 * Input was generated by ent.
 */
export type UserWhereInput = {
  and?: InputMaybe<Array<UserWhereInput>>;
  /** email field predicates */
  email?: InputMaybe<Scalars["String"]>;
  emailContains?: InputMaybe<Scalars["String"]>;
  emailContainsFold?: InputMaybe<Scalars["String"]>;
  emailEqualFold?: InputMaybe<Scalars["String"]>;
  emailGT?: InputMaybe<Scalars["String"]>;
  emailGTE?: InputMaybe<Scalars["String"]>;
  emailHasPrefix?: InputMaybe<Scalars["String"]>;
  emailHasSuffix?: InputMaybe<Scalars["String"]>;
  emailIn?: InputMaybe<Array<Scalars["String"]>>;
  emailLT?: InputMaybe<Scalars["String"]>;
  emailLTE?: InputMaybe<Scalars["String"]>;
  emailNEQ?: InputMaybe<Scalars["String"]>;
  emailNotIn?: InputMaybe<Array<Scalars["String"]>>;
  /** games edge predicates */
  hasGames?: InputMaybe<Scalars["Boolean"]>;
  hasGamesWith?: InputMaybe<Array<GameWhereInput>>;
  /** group_memberships edge predicates */
  hasGroupMemberships?: InputMaybe<Scalars["Boolean"]>;
  hasGroupMembershipsWith?: InputMaybe<Array<GroupMembershipWhereInput>>;
  /** main_player edge predicates */
  hasMainPlayer?: InputMaybe<Scalars["Boolean"]>;
  hasMainPlayerWith?: InputMaybe<Array<PlayerWhereInput>>;
  /** players edge predicates */
  hasPlayers?: InputMaybe<Scalars["Boolean"]>;
  hasPlayersWith?: InputMaybe<Array<PlayerWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars["ID"]>;
  idGT?: InputMaybe<Scalars["ID"]>;
  idGTE?: InputMaybe<Scalars["ID"]>;
  idIn?: InputMaybe<Array<Scalars["ID"]>>;
  idLT?: InputMaybe<Scalars["ID"]>;
  idLTE?: InputMaybe<Scalars["ID"]>;
  idNEQ?: InputMaybe<Scalars["ID"]>;
  idNotIn?: InputMaybe<Array<Scalars["ID"]>>;
  /** name field predicates */
  name?: InputMaybe<Scalars["String"]>;
  nameContains?: InputMaybe<Scalars["String"]>;
  nameContainsFold?: InputMaybe<Scalars["String"]>;
  nameEqualFold?: InputMaybe<Scalars["String"]>;
  nameGT?: InputMaybe<Scalars["String"]>;
  nameGTE?: InputMaybe<Scalars["String"]>;
  nameHasPrefix?: InputMaybe<Scalars["String"]>;
  nameHasSuffix?: InputMaybe<Scalars["String"]>;
  nameIn?: InputMaybe<Array<Scalars["String"]>>;
  nameLT?: InputMaybe<Scalars["String"]>;
  nameLTE?: InputMaybe<Scalars["String"]>;
  nameNEQ?: InputMaybe<Scalars["String"]>;
  nameNotIn?: InputMaybe<Array<Scalars["String"]>>;
  not?: InputMaybe<UserWhereInput>;
  or?: InputMaybe<Array<UserWhereInput>>;
};

export type GameFieldsFragment = {
  __typename?: "Game";
  id: string;
  name: string;
  description?: string | null;
  minPlayers: number;
  maxPlayers: number;
  boardgamegeekURL?: string | null;
  isFavorite: boolean;
  author: {
    __typename?: "User";
    id: string;
    name: string;
    email: string;
    avatarURL: string;
    mainPlayer?: {
      __typename?: "Player";
      id: string;
      name: string;
      owner?: { __typename?: "User"; id: string; name: string } | null;
      supervisors?: Array<{
        __typename?: "User";
        id: string;
        name: string;
      }> | null;
    } | null;
  };
  favorites: {
    __typename?: "Favorites";
    total: number;
    users: Array<{
      __typename?: "User";
      id: string;
      name: string;
      email: string;
      avatarURL: string;
      mainPlayer?: {
        __typename?: "Player";
        id: string;
        name: string;
        owner?: { __typename?: "User"; id: string; name: string } | null;
        supervisors?: Array<{
          __typename?: "User";
          id: string;
          name: string;
        }> | null;
      } | null;
    }>;
  };
  versions: Array<{
    __typename?: "GameVersion";
    id: string;
    versionNumber: number;
    statDescriptions: Array<{
      __typename?: "StatDescription";
      id: string;
      type: StatDescriptionStatType;
      name: string;
      description?: string | null;
      metadata?: string | null;
      orderNumber: number;
    }>;
    game: { __typename?: "Game"; name: string };
    metrics: {
      __typename?: "GameVersionMetrics";
      numericStats: Array<{
        __typename?: "NumericMetric";
        globalAverage: number;
        stat: { __typename?: "StatDescription"; id: string; name: string };
      }>;
      enumStats: Array<{
        __typename?: "EnumMetric";
        stat: { __typename?: "StatDescription"; id: string; name: string };
        global: Array<{
          __typename?: "EnumOccurences";
          value: string;
          occurences: number;
        }>;
      }>;
    };
  }>;
};

export type GameVersionFieldsFragment = {
  __typename?: "GameVersion";
  id: string;
  versionNumber: number;
  statDescriptions: Array<{
    __typename?: "StatDescription";
    id: string;
    type: StatDescriptionStatType;
    name: string;
    description?: string | null;
    metadata?: string | null;
    orderNumber: number;
  }>;
  game: { __typename?: "Game"; name: string };
  metrics: {
    __typename?: "GameVersionMetrics";
    numericStats: Array<{
      __typename?: "NumericMetric";
      globalAverage: number;
      stat: { __typename?: "StatDescription"; id: string; name: string };
    }>;
    enumStats: Array<{
      __typename?: "EnumMetric";
      stat: { __typename?: "StatDescription"; id: string; name: string };
      global: Array<{
        __typename?: "EnumOccurences";
        value: string;
        occurences: number;
      }>;
    }>;
  };
};

export type GroupFieldsFragment = {
  __typename?: "Group";
  id: string;
  name: string;
  description: string;
  logoURL: string;
  role?: GroupMembershipRole | null;
  applied?: boolean | null;
  settings: {
    __typename?: "GroupSettings";
    id: string;
    visibility: GroupSettingsVisibility;
    joinPolicy: GroupSettingsJoinPolicy;
    minimumRoleToInvite?: GroupMembershipRole | null;
  };
  members: { __typename?: "GroupMembershipConnection"; totalCount: number };
};

export type GroupMembershipFieldsFragment = {
  __typename?: "GroupMembership";
  id: string;
  role: GroupMembershipRole;
  user: {
    __typename?: "User";
    id: string;
    name: string;
    email: string;
    avatarURL: string;
    mainPlayer?: {
      __typename?: "Player";
      id: string;
      name: string;
      owner?: { __typename?: "User"; id: string; name: string } | null;
      supervisors?: Array<{
        __typename?: "User";
        id: string;
        name: string;
      }> | null;
    } | null;
  };
};

export type GroupMembershipApplicationFieldsFragment = {
  __typename?: "GroupMembershipApplication";
  id: string;
  message: string;
  user: {
    __typename?: "User";
    id: string;
    name: string;
    email: string;
    avatarURL: string;
    mainPlayer?: {
      __typename?: "Player";
      id: string;
      name: string;
      owner?: { __typename?: "User"; id: string; name: string } | null;
      supervisors?: Array<{
        __typename?: "User";
        id: string;
        name: string;
      }> | null;
    } | null;
  };
  group: {
    __typename?: "Group";
    id: string;
    name: string;
    description: string;
    logoURL: string;
    role?: GroupMembershipRole | null;
    applied?: boolean | null;
    settings: {
      __typename?: "GroupSettings";
      id: string;
      visibility: GroupSettingsVisibility;
      joinPolicy: GroupSettingsJoinPolicy;
      minimumRoleToInvite?: GroupMembershipRole | null;
    };
    members: { __typename?: "GroupMembershipConnection"; totalCount: number };
  };
};

export type MatchFieldsFragment = {
  __typename?: "Match";
  id: string;
  createdAt: any;
  gameVersion: {
    __typename?: "GameVersion";
    id: string;
    versionNumber: number;
    statDescriptions: Array<{
      __typename?: "StatDescription";
      id: string;
      type: StatDescriptionStatType;
      name: string;
      description?: string | null;
      metadata?: string | null;
      orderNumber: number;
    }>;
    game: { __typename?: "Game"; name: string };
    metrics: {
      __typename?: "GameVersionMetrics";
      numericStats: Array<{
        __typename?: "NumericMetric";
        globalAverage: number;
        stat: { __typename?: "StatDescription"; id: string; name: string };
      }>;
      enumStats: Array<{
        __typename?: "EnumMetric";
        stat: { __typename?: "StatDescription"; id: string; name: string };
        global: Array<{
          __typename?: "EnumOccurences";
          value: string;
          occurences: number;
        }>;
      }>;
    };
  };
  players: Array<{
    __typename?: "Player";
    id: string;
    name: string;
    owner?: { __typename?: "User"; id: string; name: string } | null;
    supervisors?: Array<{
      __typename?: "User";
      id: string;
      name: string;
    }> | null;
  }>;
  stats?: Array<{
    __typename?: "Statistic";
    value: string;
    statDescription: {
      __typename?: "StatDescription";
      id: string;
      type: StatDescriptionStatType;
      name: string;
      description?: string | null;
      metadata?: string | null;
      orderNumber: number;
    };
    player: {
      __typename?: "Player";
      id: string;
      name: string;
      owner?: { __typename?: "User"; id: string; name: string } | null;
      supervisors?: Array<{
        __typename?: "User";
        id: string;
        name: string;
      }> | null;
    };
  }> | null;
};

export type PageInfoFieldsFragment = {
  __typename?: "PageInfo";
  hasNextPage: boolean;
  hasPreviousPage: boolean;
  startCursor?: any | null;
  endCursor?: any | null;
};

export type PlayerFieldsFragment = {
  __typename?: "Player";
  id: string;
  name: string;
  owner?: { __typename?: "User"; id: string; name: string } | null;
  supervisors?: Array<{ __typename?: "User"; id: string; name: string }> | null;
};

export type PlayerSupervisionRequestFieldsFragment = {
  __typename?: "PlayerSupervisionRequest";
  id: string;
  message?: string | null;
  sender: { __typename?: "User"; id: string; name: string; avatarURL: string };
  player: {
    __typename?: "Player";
    id: string;
    name: string;
    owner?: { __typename?: "User"; id: string; name: string } | null;
    supervisors?: Array<{
      __typename?: "User";
      id: string;
      name: string;
    }> | null;
  };
  approvals?: Array<{
    __typename?: "PlayerSupervisionRequestApproval";
    approved?: boolean | null;
    approver: {
      __typename?: "User";
      id: string;
      name: string;
      avatarURL: string;
    };
  }> | null;
};

export type StatDescriptionFieldsFragment = {
  __typename?: "StatDescription";
  id: string;
  type: StatDescriptionStatType;
  name: string;
  description?: string | null;
  metadata?: string | null;
  orderNumber: number;
};

export type UserFieldsFragment = {
  __typename?: "User";
  id: string;
  name: string;
  email: string;
  avatarURL: string;
  mainPlayer?: {
    __typename?: "Player";
    id: string;
    name: string;
    owner?: { __typename?: "User"; id: string; name: string } | null;
    supervisors?: Array<{
      __typename?: "User";
      id: string;
      name: string;
    }> | null;
  } | null;
};

export type AddOrRemoveGameFromFavoritesMutationVariables = Exact<{
  id: Scalars["ID"];
  favorite: Scalars["Boolean"];
}>;

export type AddOrRemoveGameFromFavoritesMutation = {
  __typename?: "Mutation";
  addOrRemoveGameFromFavorites: boolean;
};

export type ApplyToGroupMutationVariables = Exact<{
  input: GroupApplicationInput;
}>;

export type ApplyToGroupMutation = {
  __typename?: "Mutation";
  applyToGroup: {
    __typename?: "GroupMembershipApplication";
    id: string;
    message: string;
    user: {
      __typename?: "User";
      id: string;
      name: string;
      email: string;
      avatarURL: string;
      mainPlayer?: {
        __typename?: "Player";
        id: string;
        name: string;
        owner?: { __typename?: "User"; id: string; name: string } | null;
        supervisors?: Array<{
          __typename?: "User";
          id: string;
          name: string;
        }> | null;
      } | null;
    };
    group: {
      __typename?: "Group";
      id: string;
      name: string;
      description: string;
      logoURL: string;
      role?: GroupMembershipRole | null;
      applied?: boolean | null;
      settings: {
        __typename?: "GroupSettings";
        id: string;
        visibility: GroupSettingsVisibility;
        joinPolicy: GroupSettingsJoinPolicy;
        minimumRoleToInvite?: GroupMembershipRole | null;
      };
      members: { __typename?: "GroupMembershipConnection"; totalCount: number };
    };
  };
};

export type ChangeUserGroupMembershipRoleMutationVariables = Exact<{
  userId: Scalars["ID"];
  groupId: Scalars["ID"];
  role: GroupMembershipRole;
}>;

export type ChangeUserGroupMembershipRoleMutation = {
  __typename?: "Mutation";
  changeUserGroupMembershipRole: boolean;
};

export type CreateGameMutationVariables = Exact<{
  input: CreateGameInput;
}>;

export type CreateGameMutation = {
  __typename?: "Mutation";
  createGame: {
    __typename?: "Game";
    id: string;
    name: string;
    description?: string | null;
    minPlayers: number;
    maxPlayers: number;
    boardgamegeekURL?: string | null;
    isFavorite: boolean;
    author: {
      __typename?: "User";
      id: string;
      name: string;
      email: string;
      avatarURL: string;
      mainPlayer?: {
        __typename?: "Player";
        id: string;
        name: string;
        owner?: { __typename?: "User"; id: string; name: string } | null;
        supervisors?: Array<{
          __typename?: "User";
          id: string;
          name: string;
        }> | null;
      } | null;
    };
    favorites: {
      __typename?: "Favorites";
      total: number;
      users: Array<{
        __typename?: "User";
        id: string;
        name: string;
        email: string;
        avatarURL: string;
        mainPlayer?: {
          __typename?: "Player";
          id: string;
          name: string;
          owner?: { __typename?: "User"; id: string; name: string } | null;
          supervisors?: Array<{
            __typename?: "User";
            id: string;
            name: string;
          }> | null;
        } | null;
      }>;
    };
    versions: Array<{
      __typename?: "GameVersion";
      id: string;
      versionNumber: number;
      statDescriptions: Array<{
        __typename?: "StatDescription";
        id: string;
        type: StatDescriptionStatType;
        name: string;
        description?: string | null;
        metadata?: string | null;
        orderNumber: number;
      }>;
      game: { __typename?: "Game"; name: string };
      metrics: {
        __typename?: "GameVersionMetrics";
        numericStats: Array<{
          __typename?: "NumericMetric";
          globalAverage: number;
          stat: { __typename?: "StatDescription"; id: string; name: string };
        }>;
        enumStats: Array<{
          __typename?: "EnumMetric";
          stat: { __typename?: "StatDescription"; id: string; name: string };
          global: Array<{
            __typename?: "EnumOccurences";
            value: string;
            occurences: number;
          }>;
        }>;
      };
    }>;
  };
};

export type CreateMatchMutationVariables = Exact<{
  input: CreateMatchInput;
}>;

export type CreateMatchMutation = {
  __typename?: "Mutation";
  createMatch: {
    __typename?: "Match";
    id: string;
    createdAt: any;
    gameVersion: {
      __typename?: "GameVersion";
      id: string;
      versionNumber: number;
      statDescriptions: Array<{
        __typename?: "StatDescription";
        id: string;
        type: StatDescriptionStatType;
        name: string;
        description?: string | null;
        metadata?: string | null;
        orderNumber: number;
      }>;
      game: { __typename?: "Game"; name: string };
      metrics: {
        __typename?: "GameVersionMetrics";
        numericStats: Array<{
          __typename?: "NumericMetric";
          globalAverage: number;
          stat: { __typename?: "StatDescription"; id: string; name: string };
        }>;
        enumStats: Array<{
          __typename?: "EnumMetric";
          stat: { __typename?: "StatDescription"; id: string; name: string };
          global: Array<{
            __typename?: "EnumOccurences";
            value: string;
            occurences: number;
          }>;
        }>;
      };
    };
    players: Array<{
      __typename?: "Player";
      id: string;
      name: string;
      owner?: { __typename?: "User"; id: string; name: string } | null;
      supervisors?: Array<{
        __typename?: "User";
        id: string;
        name: string;
      }> | null;
    }>;
    stats?: Array<{
      __typename?: "Statistic";
      value: string;
      statDescription: {
        __typename?: "StatDescription";
        id: string;
        type: StatDescriptionStatType;
        name: string;
        description?: string | null;
        metadata?: string | null;
        orderNumber: number;
      };
      player: {
        __typename?: "Player";
        id: string;
        name: string;
        owner?: { __typename?: "User"; id: string; name: string } | null;
        supervisors?: Array<{
          __typename?: "User";
          id: string;
          name: string;
        }> | null;
      };
    }> | null;
  };
};

export type CreateOrUpdateGroupMutationVariables = Exact<{
  id?: InputMaybe<Scalars["ID"]>;
  name: Scalars["String"];
  description?: InputMaybe<Scalars["String"]>;
  logoUrl: Scalars["String"];
  visibility: GroupSettingsVisibility;
  joinPolicy: GroupSettingsJoinPolicy;
  minimumRoleToInvite?: InputMaybe<GroupMembershipRole>;
}>;

export type CreateOrUpdateGroupMutation = {
  __typename?: "Mutation";
  createOrUpdateGroup: {
    __typename?: "Group";
    id: string;
    name: string;
    description: string;
    logoURL: string;
    role?: GroupMembershipRole | null;
    applied?: boolean | null;
    settings: {
      __typename?: "GroupSettings";
      id: string;
      visibility: GroupSettingsVisibility;
      joinPolicy: GroupSettingsJoinPolicy;
      minimumRoleToInvite?: GroupMembershipRole | null;
    };
    members: { __typename?: "GroupMembershipConnection"; totalCount: number };
  };
};

export type CreatePlayerMutationVariables = Exact<{
  name: Scalars["String"];
}>;

export type CreatePlayerMutation = {
  __typename?: "Mutation";
  createPlayer: { __typename?: "Player"; id: string; name: string };
};

export type JoinGroupMutationVariables = Exact<{
  id: Scalars["ID"];
}>;

export type JoinGroupMutation = { __typename?: "Mutation"; joinGroup: boolean };

export type KickUserFromGroupMutationVariables = Exact<{
  groupId: Scalars["ID"];
  userId: Scalars["ID"];
}>;

export type KickUserFromGroupMutation = {
  __typename?: "Mutation";
  kickUserFromGroup: boolean;
};

export type RequestPlayerSupervisionMutationVariables = Exact<{
  input: RequestPlayerSupervisionInput;
}>;

export type RequestPlayerSupervisionMutation = {
  __typename?: "Mutation";
  requestPlayerSupervision: {
    __typename?: "PlayerSupervisionRequest";
    id: string;
  };
};

export type ResolveGroupMembershipApplicationMutationVariables = Exact<{
  applicationId: Scalars["ID"];
  accepted: Scalars["Boolean"];
}>;

export type ResolveGroupMembershipApplicationMutation = {
  __typename?: "Mutation";
  resolveGroupMembershipApplication: boolean;
};

export type ResolvePlayerSupervisionRequestMutationVariables = Exact<{
  input: ResolvePlayerSupervisionRequestInput;
}>;

export type ResolvePlayerSupervisionRequestMutation = {
  __typename?: "Mutation";
  resolvePlayerSupervisionRequest: boolean;
};

export type UpdateUserMutationVariables = Exact<{
  id: Scalars["ID"];
  input: UpdateUserInput;
}>;

export type UpdateUserMutation = {
  __typename?: "Mutation";
  updateUser: { __typename?: "User"; id: string };
};

export type GroupQueryVariables = Exact<{
  id: Scalars["ID"];
}>;

export type GroupQuery = {
  __typename?: "Query";
  node?:
    | { __typename?: "Game" }
    | { __typename?: "GameVersion" }
    | {
        __typename?: "Group";
        id: string;
        name: string;
        description: string;
        logoURL: string;
        role?: GroupMembershipRole | null;
        applied?: boolean | null;
        settings: {
          __typename?: "GroupSettings";
          id: string;
          visibility: GroupSettingsVisibility;
          joinPolicy: GroupSettingsJoinPolicy;
          minimumRoleToInvite?: GroupMembershipRole | null;
        };
        members: {
          __typename?: "GroupMembershipConnection";
          totalCount: number;
        };
      }
    | { __typename?: "GroupMembership" }
    | { __typename?: "GroupMembershipApplication" }
    | { __typename?: "GroupSettings" }
    | { __typename?: "Match" }
    | { __typename?: "Player" }
    | { __typename?: "PlayerSupervisionRequest" }
    | { __typename?: "PlayerSupervisionRequestApproval" }
    | { __typename?: "StatDescription" }
    | { __typename?: "Statistic" }
    | { __typename?: "User" }
    | null;
};

export type GroupApplicationsQueryVariables = Exact<{
  id: Scalars["ID"];
}>;

export type GroupApplicationsQuery = {
  __typename?: "Query";
  node?:
    | { __typename?: "Game" }
    | { __typename?: "GameVersion" }
    | {
        __typename?: "Group";
        applications?: Array<{
          __typename?: "GroupMembershipApplication";
          id: string;
          message: string;
          user: {
            __typename?: "User";
            id: string;
            name: string;
            email: string;
            avatarURL: string;
            mainPlayer?: {
              __typename?: "Player";
              id: string;
              name: string;
              owner?: { __typename?: "User"; id: string; name: string } | null;
              supervisors?: Array<{
                __typename?: "User";
                id: string;
                name: string;
              }> | null;
            } | null;
          };
        }> | null;
      }
    | { __typename?: "GroupMembership" }
    | { __typename?: "GroupMembershipApplication" }
    | { __typename?: "GroupSettings" }
    | { __typename?: "Match" }
    | { __typename?: "Player" }
    | { __typename?: "PlayerSupervisionRequest" }
    | { __typename?: "PlayerSupervisionRequestApproval" }
    | { __typename?: "StatDescription" }
    | { __typename?: "Statistic" }
    | { __typename?: "User" }
    | null;
};

export type GroupMembersQueryVariables = Exact<{
  groupId: Scalars["ID"];
  before?: InputMaybe<Scalars["Cursor"]>;
  after?: InputMaybe<Scalars["Cursor"]>;
  first?: InputMaybe<Scalars["Int"]>;
  last?: InputMaybe<Scalars["Int"]>;
  where?: InputMaybe<GroupMembershipWhereInput>;
}>;

export type GroupMembersQuery = {
  __typename?: "Query";
  node?:
    | { __typename?: "Game" }
    | { __typename?: "GameVersion" }
    | {
        __typename?: "Group";
        members: {
          __typename?: "GroupMembershipConnection";
          totalCount: number;
          pageInfo: {
            __typename?: "PageInfo";
            hasNextPage: boolean;
            hasPreviousPage: boolean;
            startCursor?: any | null;
            endCursor?: any | null;
          };
          edges?: Array<{
            __typename?: "GroupMembershipEdge";
            node?: {
              __typename?: "GroupMembership";
              id: string;
              role: GroupMembershipRole;
              user: {
                __typename?: "User";
                id: string;
                name: string;
                email: string;
                avatarURL: string;
                mainPlayer?: {
                  __typename?: "Player";
                  id: string;
                  name: string;
                  owner?: {
                    __typename?: "User";
                    id: string;
                    name: string;
                  } | null;
                  supervisors?: Array<{
                    __typename?: "User";
                    id: string;
                    name: string;
                  }> | null;
                } | null;
              };
            } | null;
          } | null> | null;
        };
      }
    | { __typename?: "GroupMembership" }
    | { __typename?: "GroupMembershipApplication" }
    | { __typename?: "GroupSettings" }
    | { __typename?: "Match" }
    | { __typename?: "Player" }
    | { __typename?: "PlayerSupervisionRequest" }
    | { __typename?: "PlayerSupervisionRequestApproval" }
    | { __typename?: "StatDescription" }
    | { __typename?: "Statistic" }
    | { __typename?: "User" }
    | null;
};

export type GroupSettingsQueryVariables = Exact<{
  id: Scalars["ID"];
}>;

export type GroupSettingsQuery = {
  __typename?: "Query";
  node?:
    | { __typename?: "Game" }
    | { __typename?: "GameVersion" }
    | {
        __typename?: "Group";
        id: string;
        name: string;
        description: string;
        logoURL: string;
        settings: {
          __typename?: "GroupSettings";
          id: string;
          visibility: GroupSettingsVisibility;
          joinPolicy: GroupSettingsJoinPolicy;
          minimumRoleToInvite?: GroupMembershipRole | null;
        };
      }
    | { __typename?: "GroupMembership" }
    | { __typename?: "GroupMembershipApplication" }
    | { __typename?: "GroupSettings" }
    | { __typename?: "Match" }
    | { __typename?: "Player" }
    | { __typename?: "PlayerSupervisionRequest" }
    | { __typename?: "PlayerSupervisionRequestApproval" }
    | { __typename?: "StatDescription" }
    | { __typename?: "Statistic" }
    | { __typename?: "User" }
    | null;
};

export type IncomingSupervisionRequestsQueryVariables = Exact<{
  [key: string]: never;
}>;

export type IncomingSupervisionRequestsQuery = {
  __typename?: "Query";
  me: {
    __typename?: "User";
    receivedSupervisionRequests: Array<{
      __typename?: "PlayerSupervisionRequest";
      id: string;
      message?: string | null;
      sender: {
        __typename?: "User";
        id: string;
        name: string;
        avatarURL: string;
      };
      player: {
        __typename?: "Player";
        id: string;
        name: string;
        owner?: { __typename?: "User"; id: string; name: string } | null;
        supervisors?: Array<{
          __typename?: "User";
          id: string;
          name: string;
        }> | null;
      };
      approvals?: Array<{
        __typename?: "PlayerSupervisionRequestApproval";
        approved?: boolean | null;
        approver: {
          __typename?: "User";
          id: string;
          name: string;
          avatarURL: string;
        };
      }> | null;
    }>;
  };
};

export type MatchQueryVariables = Exact<{
  id: Scalars["ID"];
}>;

export type MatchQuery = {
  __typename?: "Query";
  node?:
    | { __typename?: "Game" }
    | { __typename?: "GameVersion" }
    | { __typename?: "Group" }
    | { __typename?: "GroupMembership" }
    | { __typename?: "GroupMembershipApplication" }
    | { __typename?: "GroupSettings" }
    | {
        __typename?: "Match";
        id: string;
        createdAt: any;
        gameVersion: {
          __typename?: "GameVersion";
          id: string;
          versionNumber: number;
          statDescriptions: Array<{
            __typename?: "StatDescription";
            id: string;
            type: StatDescriptionStatType;
            name: string;
            description?: string | null;
            metadata?: string | null;
            orderNumber: number;
          }>;
          game: { __typename?: "Game"; name: string };
          metrics: {
            __typename?: "GameVersionMetrics";
            numericStats: Array<{
              __typename?: "NumericMetric";
              globalAverage: number;
              stat: {
                __typename?: "StatDescription";
                id: string;
                name: string;
              };
            }>;
            enumStats: Array<{
              __typename?: "EnumMetric";
              stat: {
                __typename?: "StatDescription";
                id: string;
                name: string;
              };
              global: Array<{
                __typename?: "EnumOccurences";
                value: string;
                occurences: number;
              }>;
            }>;
          };
        };
        players: Array<{
          __typename?: "Player";
          id: string;
          name: string;
          owner?: { __typename?: "User"; id: string; name: string } | null;
          supervisors?: Array<{
            __typename?: "User";
            id: string;
            name: string;
          }> | null;
        }>;
        stats?: Array<{
          __typename?: "Statistic";
          value: string;
          statDescription: {
            __typename?: "StatDescription";
            id: string;
            type: StatDescriptionStatType;
            name: string;
            description?: string | null;
            metadata?: string | null;
            orderNumber: number;
          };
          player: {
            __typename?: "Player";
            id: string;
            name: string;
            owner?: { __typename?: "User"; id: string; name: string } | null;
            supervisors?: Array<{
              __typename?: "User";
              id: string;
              name: string;
            }> | null;
          };
        }> | null;
      }
    | { __typename?: "Player" }
    | { __typename?: "PlayerSupervisionRequest" }
    | { __typename?: "PlayerSupervisionRequestApproval" }
    | { __typename?: "StatDescription" }
    | { __typename?: "Statistic" }
    | { __typename?: "User" }
    | null;
};

export type MeQueryVariables = Exact<{ [key: string]: never }>;

export type MeQuery = {
  __typename?: "Query";
  me: {
    __typename?: "User";
    id: string;
    name: string;
    email: string;
    avatarURL: string;
    mainPlayer?: {
      __typename?: "Player";
      id: string;
      name: string;
      owner?: { __typename?: "User"; id: string; name: string } | null;
      supervisors?: Array<{
        __typename?: "User";
        id: string;
        name: string;
      }> | null;
    } | null;
  };
};

export type MyPlayersQueryVariables = Exact<{ [key: string]: never }>;

export type MyPlayersQuery = {
  __typename?: "Query";
  me: {
    __typename?: "User";
    players?: Array<{
      __typename?: "Player";
      id: string;
      name: string;
      owner?: { __typename?: "User"; id: string; name: string } | null;
      supervisors?: Array<{
        __typename?: "User";
        id: string;
        name: string;
      }> | null;
    }> | null;
  };
};

export type PendingSupervisionRequestsQueryVariables = Exact<{
  [key: string]: never;
}>;

export type PendingSupervisionRequestsQuery = {
  __typename?: "Query";
  me: {
    __typename?: "User";
    sentSupervisionRequests: Array<{
      __typename?: "PlayerSupervisionRequest";
      id: string;
      message?: string | null;
      sender: {
        __typename?: "User";
        id: string;
        name: string;
        avatarURL: string;
      };
      player: {
        __typename?: "Player";
        id: string;
        name: string;
        owner?: { __typename?: "User"; id: string; name: string } | null;
        supervisors?: Array<{
          __typename?: "User";
          id: string;
          name: string;
        }> | null;
      };
      approvals?: Array<{
        __typename?: "PlayerSupervisionRequestApproval";
        approved?: boolean | null;
        approver: {
          __typename?: "User";
          id: string;
          name: string;
          avatarURL: string;
        };
      }> | null;
    }>;
  };
};

export type PresignUploadUrlQueryVariables = Exact<{ [key: string]: never }>;

export type PresignUploadUrlQuery = {
  __typename?: "Query";
  preSignUploadURL: {
    __typename?: "UploadURL";
    url: string;
    headers: Array<{ __typename?: "Header"; key: string; value: string }>;
  };
};

export type SearchGamesQueryVariables = Exact<{
  before?: InputMaybe<Scalars["Cursor"]>;
  after?: InputMaybe<Scalars["Cursor"]>;
  where: GameWhereInput;
  first?: InputMaybe<Scalars["Int"]>;
  last?: InputMaybe<Scalars["Int"]>;
}>;

export type SearchGamesQuery = {
  __typename?: "Query";
  games: {
    __typename?: "GameConnection";
    totalCount: number;
    pageInfo: {
      __typename?: "PageInfo";
      hasNextPage: boolean;
      hasPreviousPage: boolean;
      startCursor?: any | null;
      endCursor?: any | null;
    };
    edges?: Array<{
      __typename?: "GameEdge";
      node?: {
        __typename?: "Game";
        id: string;
        name: string;
        description?: string | null;
        minPlayers: number;
        maxPlayers: number;
        boardgamegeekURL?: string | null;
        isFavorite: boolean;
        author: {
          __typename?: "User";
          id: string;
          name: string;
          email: string;
          avatarURL: string;
          mainPlayer?: {
            __typename?: "Player";
            id: string;
            name: string;
            owner?: { __typename?: "User"; id: string; name: string } | null;
            supervisors?: Array<{
              __typename?: "User";
              id: string;
              name: string;
            }> | null;
          } | null;
        };
        favorites: {
          __typename?: "Favorites";
          total: number;
          users: Array<{
            __typename?: "User";
            id: string;
            name: string;
            email: string;
            avatarURL: string;
            mainPlayer?: {
              __typename?: "Player";
              id: string;
              name: string;
              owner?: { __typename?: "User"; id: string; name: string } | null;
              supervisors?: Array<{
                __typename?: "User";
                id: string;
                name: string;
              }> | null;
            } | null;
          }>;
        };
        versions: Array<{
          __typename?: "GameVersion";
          id: string;
          versionNumber: number;
          statDescriptions: Array<{
            __typename?: "StatDescription";
            id: string;
            type: StatDescriptionStatType;
            name: string;
            description?: string | null;
            metadata?: string | null;
            orderNumber: number;
          }>;
          game: { __typename?: "Game"; name: string };
          metrics: {
            __typename?: "GameVersionMetrics";
            numericStats: Array<{
              __typename?: "NumericMetric";
              globalAverage: number;
              stat: {
                __typename?: "StatDescription";
                id: string;
                name: string;
              };
            }>;
            enumStats: Array<{
              __typename?: "EnumMetric";
              stat: {
                __typename?: "StatDescription";
                id: string;
                name: string;
              };
              global: Array<{
                __typename?: "EnumOccurences";
                value: string;
                occurences: number;
              }>;
            }>;
          };
        }>;
      } | null;
    } | null> | null;
  };
};

export type SearchGroupsQueryVariables = Exact<{
  before?: InputMaybe<Scalars["Cursor"]>;
  after?: InputMaybe<Scalars["Cursor"]>;
  where: GroupWhereInput;
  first?: InputMaybe<Scalars["Int"]>;
  last?: InputMaybe<Scalars["Int"]>;
}>;

export type SearchGroupsQuery = {
  __typename?: "Query";
  groups: {
    __typename?: "GroupConnection";
    totalCount: number;
    pageInfo: {
      __typename?: "PageInfo";
      hasNextPage: boolean;
      hasPreviousPage: boolean;
      startCursor?: any | null;
      endCursor?: any | null;
    };
    edges?: Array<{
      __typename?: "GroupEdge";
      node?: {
        __typename?: "Group";
        id: string;
        name: string;
        description: string;
        logoURL: string;
        role?: GroupMembershipRole | null;
        applied?: boolean | null;
        settings: {
          __typename?: "GroupSettings";
          id: string;
          visibility: GroupSettingsVisibility;
          joinPolicy: GroupSettingsJoinPolicy;
          minimumRoleToInvite?: GroupMembershipRole | null;
        };
        members: {
          __typename?: "GroupMembershipConnection";
          totalCount: number;
        };
      } | null;
    } | null> | null;
  };
};

export type SearchMatchesQueryVariables = Exact<{
  before?: InputMaybe<Scalars["Cursor"]>;
  after?: InputMaybe<Scalars["Cursor"]>;
  where: MatchWhereInput;
  first?: InputMaybe<Scalars["Int"]>;
  last?: InputMaybe<Scalars["Int"]>;
}>;

export type SearchMatchesQuery = {
  __typename?: "Query";
  matches: {
    __typename?: "MatchConnection";
    totalCount: number;
    pageInfo: {
      __typename?: "PageInfo";
      hasNextPage: boolean;
      hasPreviousPage: boolean;
      startCursor?: any | null;
      endCursor?: any | null;
    };
    edges?: Array<{
      __typename?: "MatchEdge";
      node?: {
        __typename?: "Match";
        id: string;
        createdAt: any;
        gameVersion: {
          __typename?: "GameVersion";
          id: string;
          versionNumber: number;
          statDescriptions: Array<{
            __typename?: "StatDescription";
            id: string;
            type: StatDescriptionStatType;
            name: string;
            description?: string | null;
            metadata?: string | null;
            orderNumber: number;
          }>;
          game: { __typename?: "Game"; name: string };
          metrics: {
            __typename?: "GameVersionMetrics";
            numericStats: Array<{
              __typename?: "NumericMetric";
              globalAverage: number;
              stat: {
                __typename?: "StatDescription";
                id: string;
                name: string;
              };
            }>;
            enumStats: Array<{
              __typename?: "EnumMetric";
              stat: {
                __typename?: "StatDescription";
                id: string;
                name: string;
              };
              global: Array<{
                __typename?: "EnumOccurences";
                value: string;
                occurences: number;
              }>;
            }>;
          };
        };
        players: Array<{
          __typename?: "Player";
          id: string;
          name: string;
          owner?: { __typename?: "User"; id: string; name: string } | null;
          supervisors?: Array<{
            __typename?: "User";
            id: string;
            name: string;
          }> | null;
        }>;
        stats?: Array<{
          __typename?: "Statistic";
          value: string;
          statDescription: {
            __typename?: "StatDescription";
            id: string;
            type: StatDescriptionStatType;
            name: string;
            description?: string | null;
            metadata?: string | null;
            orderNumber: number;
          };
          player: {
            __typename?: "Player";
            id: string;
            name: string;
            owner?: { __typename?: "User"; id: string; name: string } | null;
            supervisors?: Array<{
              __typename?: "User";
              id: string;
              name: string;
            }> | null;
          };
        }> | null;
      } | null;
    } | null> | null;
  };
};

export type SearchPlayersQueryVariables = Exact<{
  before?: InputMaybe<Scalars["Cursor"]>;
  after?: InputMaybe<Scalars["Cursor"]>;
  where: PlayerWhereInput;
  first?: InputMaybe<Scalars["Int"]>;
  last?: InputMaybe<Scalars["Int"]>;
}>;

export type SearchPlayersQuery = {
  __typename?: "Query";
  players: {
    __typename?: "PlayerConnection";
    totalCount: number;
    pageInfo: {
      __typename?: "PageInfo";
      hasNextPage: boolean;
      hasPreviousPage: boolean;
      startCursor?: any | null;
      endCursor?: any | null;
    };
    edges?: Array<{
      __typename?: "PlayerEdge";
      cursor: any;
      node?: {
        __typename?: "Player";
        id: string;
        name: string;
        owner?: { __typename?: "User"; id: string; name: string } | null;
        supervisors?: Array<{
          __typename?: "User";
          id: string;
          name: string;
        }> | null;
      } | null;
    } | null> | null;
  };
};

export const PlayerFieldsFragmentDoc = gql`
  fragment playerFields on Player {
    id
    name
    owner {
      id
      name
    }
    supervisors {
      id
      name
    }
  }
`;
export const UserFieldsFragmentDoc = gql`
  fragment userFields on User {
    id
    name
    email
    avatarURL
    mainPlayer {
      ...playerFields
    }
  }
  ${PlayerFieldsFragmentDoc}
`;
export const StatDescriptionFieldsFragmentDoc = gql`
  fragment statDescriptionFields on StatDescription {
    id
    type
    name
    description
    metadata
    orderNumber
  }
`;
export const GameVersionFieldsFragmentDoc = gql`
  fragment gameVersionFields on GameVersion {
    id
    versionNumber
    statDescriptions {
      ...statDescriptionFields
    }
    game {
      name
    }
    metrics {
      numericStats {
        stat {
          id
          name
        }
        globalAverage
      }
      enumStats {
        stat {
          id
          name
        }
        global {
          value
          occurences
        }
      }
    }
  }
  ${StatDescriptionFieldsFragmentDoc}
`;
export const GameFieldsFragmentDoc = gql`
  fragment gameFields on Game {
    id
    name
    description
    minPlayers
    maxPlayers
    boardgamegeekURL
    author {
      ...userFields
    }
    isFavorite
    favorites {
      total
      users {
        ...userFields
      }
    }
    versions {
      ...gameVersionFields
    }
  }
  ${UserFieldsFragmentDoc}
  ${GameVersionFieldsFragmentDoc}
`;
export const GroupMembershipFieldsFragmentDoc = gql`
  fragment groupMembershipFields on GroupMembership {
    id
    role
    user {
      ...userFields
    }
  }
  ${UserFieldsFragmentDoc}
`;
export const GroupFieldsFragmentDoc = gql`
  fragment groupFields on Group {
    id
    name
    description
    logoURL
    settings {
      id
      visibility
      joinPolicy
      minimumRoleToInvite
    }
    members {
      totalCount
    }
    role
    applied
  }
`;
export const GroupMembershipApplicationFieldsFragmentDoc = gql`
  fragment groupMembershipApplicationFields on GroupMembershipApplication {
    id
    message
    user {
      ...userFields
    }
    group {
      ...groupFields
    }
  }
  ${UserFieldsFragmentDoc}
  ${GroupFieldsFragmentDoc}
`;
export const MatchFieldsFragmentDoc = gql`
  fragment matchFields on Match {
    id
    gameVersion {
      ...gameVersionFields
    }
    players {
      ...playerFields
    }
    stats {
      value
      statDescription {
        ...statDescriptionFields
      }
      player {
        ...playerFields
      }
    }
    createdAt
  }
  ${GameVersionFieldsFragmentDoc}
  ${PlayerFieldsFragmentDoc}
  ${StatDescriptionFieldsFragmentDoc}
`;
export const PageInfoFieldsFragmentDoc = gql`
  fragment pageInfoFields on PageInfo {
    hasNextPage
    hasPreviousPage
    startCursor
    endCursor
  }
`;
export const PlayerSupervisionRequestFieldsFragmentDoc = gql`
  fragment playerSupervisionRequestFields on PlayerSupervisionRequest {
    id
    message
    sender {
      id
      name
      avatarURL
    }
    player {
      ...playerFields
    }
    approvals {
      approved
      approver {
        id
        name
        avatarURL
      }
    }
  }
  ${PlayerFieldsFragmentDoc}
`;
export const AddOrRemoveGameFromFavoritesDocument = gql`
  mutation AddOrRemoveGameFromFavorites($id: ID!, $favorite: Boolean!) {
    addOrRemoveGameFromFavorites(gameId: $id, favorite: $favorite)
  }
`;
export type AddOrRemoveGameFromFavoritesMutationFn = Apollo.MutationFunction<
  AddOrRemoveGameFromFavoritesMutation,
  AddOrRemoveGameFromFavoritesMutationVariables
>;

/**
 * __useAddOrRemoveGameFromFavoritesMutation__
 *
 * To run a mutation, you first call `useAddOrRemoveGameFromFavoritesMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddOrRemoveGameFromFavoritesMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addOrRemoveGameFromFavoritesMutation, { data, loading, error }] = useAddOrRemoveGameFromFavoritesMutation({
 *   variables: {
 *      id: // value for 'id'
 *      favorite: // value for 'favorite'
 *   },
 * });
 */
export function useAddOrRemoveGameFromFavoritesMutation(
  baseOptions?: Apollo.MutationHookOptions<
    AddOrRemoveGameFromFavoritesMutation,
    AddOrRemoveGameFromFavoritesMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useMutation<
    AddOrRemoveGameFromFavoritesMutation,
    AddOrRemoveGameFromFavoritesMutationVariables
  >(AddOrRemoveGameFromFavoritesDocument, options);
}
export type AddOrRemoveGameFromFavoritesMutationHookResult = ReturnType<
  typeof useAddOrRemoveGameFromFavoritesMutation
>;
export type AddOrRemoveGameFromFavoritesMutationResult =
  Apollo.MutationResult<AddOrRemoveGameFromFavoritesMutation>;
export type AddOrRemoveGameFromFavoritesMutationOptions =
  Apollo.BaseMutationOptions<
    AddOrRemoveGameFromFavoritesMutation,
    AddOrRemoveGameFromFavoritesMutationVariables
  >;
export const ApplyToGroupDocument = gql`
  mutation ApplyToGroup($input: GroupApplicationInput!) {
    applyToGroup(input: $input) {
      ...groupMembershipApplicationFields
    }
  }
  ${GroupMembershipApplicationFieldsFragmentDoc}
`;
export type ApplyToGroupMutationFn = Apollo.MutationFunction<
  ApplyToGroupMutation,
  ApplyToGroupMutationVariables
>;

/**
 * __useApplyToGroupMutation__
 *
 * To run a mutation, you first call `useApplyToGroupMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useApplyToGroupMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [applyToGroupMutation, { data, loading, error }] = useApplyToGroupMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useApplyToGroupMutation(
  baseOptions?: Apollo.MutationHookOptions<
    ApplyToGroupMutation,
    ApplyToGroupMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useMutation<
    ApplyToGroupMutation,
    ApplyToGroupMutationVariables
  >(ApplyToGroupDocument, options);
}
export type ApplyToGroupMutationHookResult = ReturnType<
  typeof useApplyToGroupMutation
>;
export type ApplyToGroupMutationResult =
  Apollo.MutationResult<ApplyToGroupMutation>;
export type ApplyToGroupMutationOptions = Apollo.BaseMutationOptions<
  ApplyToGroupMutation,
  ApplyToGroupMutationVariables
>;
export const ChangeUserGroupMembershipRoleDocument = gql`
  mutation ChangeUserGroupMembershipRole(
    $userId: ID!
    $groupId: ID!
    $role: GroupMembershipRole!
  ) {
    changeUserGroupMembershipRole(
      userId: $userId
      groupId: $groupId
      role: $role
    )
  }
`;
export type ChangeUserGroupMembershipRoleMutationFn = Apollo.MutationFunction<
  ChangeUserGroupMembershipRoleMutation,
  ChangeUserGroupMembershipRoleMutationVariables
>;

/**
 * __useChangeUserGroupMembershipRoleMutation__
 *
 * To run a mutation, you first call `useChangeUserGroupMembershipRoleMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useChangeUserGroupMembershipRoleMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [changeUserGroupMembershipRoleMutation, { data, loading, error }] = useChangeUserGroupMembershipRoleMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      groupId: // value for 'groupId'
 *      role: // value for 'role'
 *   },
 * });
 */
export function useChangeUserGroupMembershipRoleMutation(
  baseOptions?: Apollo.MutationHookOptions<
    ChangeUserGroupMembershipRoleMutation,
    ChangeUserGroupMembershipRoleMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useMutation<
    ChangeUserGroupMembershipRoleMutation,
    ChangeUserGroupMembershipRoleMutationVariables
  >(ChangeUserGroupMembershipRoleDocument, options);
}
export type ChangeUserGroupMembershipRoleMutationHookResult = ReturnType<
  typeof useChangeUserGroupMembershipRoleMutation
>;
export type ChangeUserGroupMembershipRoleMutationResult =
  Apollo.MutationResult<ChangeUserGroupMembershipRoleMutation>;
export type ChangeUserGroupMembershipRoleMutationOptions =
  Apollo.BaseMutationOptions<
    ChangeUserGroupMembershipRoleMutation,
    ChangeUserGroupMembershipRoleMutationVariables
  >;
export const CreateGameDocument = gql`
  mutation CreateGame($input: CreateGameInput!) {
    createGame(input: $input) {
      ...gameFields
    }
  }
  ${GameFieldsFragmentDoc}
`;
export type CreateGameMutationFn = Apollo.MutationFunction<
  CreateGameMutation,
  CreateGameMutationVariables
>;

/**
 * __useCreateGameMutation__
 *
 * To run a mutation, you first call `useCreateGameMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateGameMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createGameMutation, { data, loading, error }] = useCreateGameMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateGameMutation(
  baseOptions?: Apollo.MutationHookOptions<
    CreateGameMutation,
    CreateGameMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useMutation<CreateGameMutation, CreateGameMutationVariables>(
    CreateGameDocument,
    options
  );
}
export type CreateGameMutationHookResult = ReturnType<
  typeof useCreateGameMutation
>;
export type CreateGameMutationResult =
  Apollo.MutationResult<CreateGameMutation>;
export type CreateGameMutationOptions = Apollo.BaseMutationOptions<
  CreateGameMutation,
  CreateGameMutationVariables
>;
export const CreateMatchDocument = gql`
  mutation CreateMatch($input: CreateMatchInput!) {
    createMatch(input: $input) {
      ...matchFields
    }
  }
  ${MatchFieldsFragmentDoc}
`;
export type CreateMatchMutationFn = Apollo.MutationFunction<
  CreateMatchMutation,
  CreateMatchMutationVariables
>;

/**
 * __useCreateMatchMutation__
 *
 * To run a mutation, you first call `useCreateMatchMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateMatchMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createMatchMutation, { data, loading, error }] = useCreateMatchMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateMatchMutation(
  baseOptions?: Apollo.MutationHookOptions<
    CreateMatchMutation,
    CreateMatchMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useMutation<CreateMatchMutation, CreateMatchMutationVariables>(
    CreateMatchDocument,
    options
  );
}
export type CreateMatchMutationHookResult = ReturnType<
  typeof useCreateMatchMutation
>;
export type CreateMatchMutationResult =
  Apollo.MutationResult<CreateMatchMutation>;
export type CreateMatchMutationOptions = Apollo.BaseMutationOptions<
  CreateMatchMutation,
  CreateMatchMutationVariables
>;
export const CreateOrUpdateGroupDocument = gql`
  mutation CreateOrUpdateGroup(
    $id: ID
    $name: String!
    $description: String
    $logoUrl: String!
    $visibility: GroupSettingsVisibility!
    $joinPolicy: GroupSettingsJoinPolicy!
    $minimumRoleToInvite: GroupMembershipRole
  ) {
    createOrUpdateGroup(
      input: {
        id: $id
        name: $name
        description: $description
        logoUrl: $logoUrl
        settings: {
          visibility: $visibility
          joinPolicy: $joinPolicy
          minimumRoleToInvite: $minimumRoleToInvite
        }
      }
    ) {
      ...groupFields
    }
  }
  ${GroupFieldsFragmentDoc}
`;
export type CreateOrUpdateGroupMutationFn = Apollo.MutationFunction<
  CreateOrUpdateGroupMutation,
  CreateOrUpdateGroupMutationVariables
>;

/**
 * __useCreateOrUpdateGroupMutation__
 *
 * To run a mutation, you first call `useCreateOrUpdateGroupMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateOrUpdateGroupMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createOrUpdateGroupMutation, { data, loading, error }] = useCreateOrUpdateGroupMutation({
 *   variables: {
 *      id: // value for 'id'
 *      name: // value for 'name'
 *      description: // value for 'description'
 *      logoUrl: // value for 'logoUrl'
 *      visibility: // value for 'visibility'
 *      joinPolicy: // value for 'joinPolicy'
 *      minimumRoleToInvite: // value for 'minimumRoleToInvite'
 *   },
 * });
 */
export function useCreateOrUpdateGroupMutation(
  baseOptions?: Apollo.MutationHookOptions<
    CreateOrUpdateGroupMutation,
    CreateOrUpdateGroupMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useMutation<
    CreateOrUpdateGroupMutation,
    CreateOrUpdateGroupMutationVariables
  >(CreateOrUpdateGroupDocument, options);
}
export type CreateOrUpdateGroupMutationHookResult = ReturnType<
  typeof useCreateOrUpdateGroupMutation
>;
export type CreateOrUpdateGroupMutationResult =
  Apollo.MutationResult<CreateOrUpdateGroupMutation>;
export type CreateOrUpdateGroupMutationOptions = Apollo.BaseMutationOptions<
  CreateOrUpdateGroupMutation,
  CreateOrUpdateGroupMutationVariables
>;
export const CreatePlayerDocument = gql`
  mutation CreatePlayer($name: String!) {
    createPlayer(input: { name: $name }) {
      id
      name
    }
  }
`;
export type CreatePlayerMutationFn = Apollo.MutationFunction<
  CreatePlayerMutation,
  CreatePlayerMutationVariables
>;

/**
 * __useCreatePlayerMutation__
 *
 * To run a mutation, you first call `useCreatePlayerMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreatePlayerMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createPlayerMutation, { data, loading, error }] = useCreatePlayerMutation({
 *   variables: {
 *      name: // value for 'name'
 *   },
 * });
 */
export function useCreatePlayerMutation(
  baseOptions?: Apollo.MutationHookOptions<
    CreatePlayerMutation,
    CreatePlayerMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useMutation<
    CreatePlayerMutation,
    CreatePlayerMutationVariables
  >(CreatePlayerDocument, options);
}
export type CreatePlayerMutationHookResult = ReturnType<
  typeof useCreatePlayerMutation
>;
export type CreatePlayerMutationResult =
  Apollo.MutationResult<CreatePlayerMutation>;
export type CreatePlayerMutationOptions = Apollo.BaseMutationOptions<
  CreatePlayerMutation,
  CreatePlayerMutationVariables
>;
export const JoinGroupDocument = gql`
  mutation JoinGroup($id: ID!) {
    joinGroup(groupId: $id)
  }
`;
export type JoinGroupMutationFn = Apollo.MutationFunction<
  JoinGroupMutation,
  JoinGroupMutationVariables
>;

/**
 * __useJoinGroupMutation__
 *
 * To run a mutation, you first call `useJoinGroupMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useJoinGroupMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [joinGroupMutation, { data, loading, error }] = useJoinGroupMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useJoinGroupMutation(
  baseOptions?: Apollo.MutationHookOptions<
    JoinGroupMutation,
    JoinGroupMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useMutation<JoinGroupMutation, JoinGroupMutationVariables>(
    JoinGroupDocument,
    options
  );
}
export type JoinGroupMutationHookResult = ReturnType<
  typeof useJoinGroupMutation
>;
export type JoinGroupMutationResult = Apollo.MutationResult<JoinGroupMutation>;
export type JoinGroupMutationOptions = Apollo.BaseMutationOptions<
  JoinGroupMutation,
  JoinGroupMutationVariables
>;
export const KickUserFromGroupDocument = gql`
  mutation KickUserFromGroup($groupId: ID!, $userId: ID!) {
    kickUserFromGroup(groupId: $groupId, userId: $userId)
  }
`;
export type KickUserFromGroupMutationFn = Apollo.MutationFunction<
  KickUserFromGroupMutation,
  KickUserFromGroupMutationVariables
>;

/**
 * __useKickUserFromGroupMutation__
 *
 * To run a mutation, you first call `useKickUserFromGroupMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useKickUserFromGroupMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [kickUserFromGroupMutation, { data, loading, error }] = useKickUserFromGroupMutation({
 *   variables: {
 *      groupId: // value for 'groupId'
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useKickUserFromGroupMutation(
  baseOptions?: Apollo.MutationHookOptions<
    KickUserFromGroupMutation,
    KickUserFromGroupMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useMutation<
    KickUserFromGroupMutation,
    KickUserFromGroupMutationVariables
  >(KickUserFromGroupDocument, options);
}
export type KickUserFromGroupMutationHookResult = ReturnType<
  typeof useKickUserFromGroupMutation
>;
export type KickUserFromGroupMutationResult =
  Apollo.MutationResult<KickUserFromGroupMutation>;
export type KickUserFromGroupMutationOptions = Apollo.BaseMutationOptions<
  KickUserFromGroupMutation,
  KickUserFromGroupMutationVariables
>;
export const RequestPlayerSupervisionDocument = gql`
  mutation RequestPlayerSupervision($input: RequestPlayerSupervisionInput!) {
    requestPlayerSupervision(input: $input) {
      id
    }
  }
`;
export type RequestPlayerSupervisionMutationFn = Apollo.MutationFunction<
  RequestPlayerSupervisionMutation,
  RequestPlayerSupervisionMutationVariables
>;

/**
 * __useRequestPlayerSupervisionMutation__
 *
 * To run a mutation, you first call `useRequestPlayerSupervisionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRequestPlayerSupervisionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [requestPlayerSupervisionMutation, { data, loading, error }] = useRequestPlayerSupervisionMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useRequestPlayerSupervisionMutation(
  baseOptions?: Apollo.MutationHookOptions<
    RequestPlayerSupervisionMutation,
    RequestPlayerSupervisionMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useMutation<
    RequestPlayerSupervisionMutation,
    RequestPlayerSupervisionMutationVariables
  >(RequestPlayerSupervisionDocument, options);
}
export type RequestPlayerSupervisionMutationHookResult = ReturnType<
  typeof useRequestPlayerSupervisionMutation
>;
export type RequestPlayerSupervisionMutationResult =
  Apollo.MutationResult<RequestPlayerSupervisionMutation>;
export type RequestPlayerSupervisionMutationOptions =
  Apollo.BaseMutationOptions<
    RequestPlayerSupervisionMutation,
    RequestPlayerSupervisionMutationVariables
  >;
export const ResolveGroupMembershipApplicationDocument = gql`
  mutation ResolveGroupMembershipApplication(
    $applicationId: ID!
    $accepted: Boolean!
  ) {
    resolveGroupMembershipApplication(
      applicationId: $applicationId
      accepted: $accepted
    )
  }
`;
export type ResolveGroupMembershipApplicationMutationFn =
  Apollo.MutationFunction<
    ResolveGroupMembershipApplicationMutation,
    ResolveGroupMembershipApplicationMutationVariables
  >;

/**
 * __useResolveGroupMembershipApplicationMutation__
 *
 * To run a mutation, you first call `useResolveGroupMembershipApplicationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useResolveGroupMembershipApplicationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [resolveGroupMembershipApplicationMutation, { data, loading, error }] = useResolveGroupMembershipApplicationMutation({
 *   variables: {
 *      applicationId: // value for 'applicationId'
 *      accepted: // value for 'accepted'
 *   },
 * });
 */
export function useResolveGroupMembershipApplicationMutation(
  baseOptions?: Apollo.MutationHookOptions<
    ResolveGroupMembershipApplicationMutation,
    ResolveGroupMembershipApplicationMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useMutation<
    ResolveGroupMembershipApplicationMutation,
    ResolveGroupMembershipApplicationMutationVariables
  >(ResolveGroupMembershipApplicationDocument, options);
}
export type ResolveGroupMembershipApplicationMutationHookResult = ReturnType<
  typeof useResolveGroupMembershipApplicationMutation
>;
export type ResolveGroupMembershipApplicationMutationResult =
  Apollo.MutationResult<ResolveGroupMembershipApplicationMutation>;
export type ResolveGroupMembershipApplicationMutationOptions =
  Apollo.BaseMutationOptions<
    ResolveGroupMembershipApplicationMutation,
    ResolveGroupMembershipApplicationMutationVariables
  >;
export const ResolvePlayerSupervisionRequestDocument = gql`
  mutation ResolvePlayerSupervisionRequest(
    $input: ResolvePlayerSupervisionRequestInput!
  ) {
    resolvePlayerSupervisionRequest(input: $input)
  }
`;
export type ResolvePlayerSupervisionRequestMutationFn = Apollo.MutationFunction<
  ResolvePlayerSupervisionRequestMutation,
  ResolvePlayerSupervisionRequestMutationVariables
>;

/**
 * __useResolvePlayerSupervisionRequestMutation__
 *
 * To run a mutation, you first call `useResolvePlayerSupervisionRequestMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useResolvePlayerSupervisionRequestMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [resolvePlayerSupervisionRequestMutation, { data, loading, error }] = useResolvePlayerSupervisionRequestMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useResolvePlayerSupervisionRequestMutation(
  baseOptions?: Apollo.MutationHookOptions<
    ResolvePlayerSupervisionRequestMutation,
    ResolvePlayerSupervisionRequestMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useMutation<
    ResolvePlayerSupervisionRequestMutation,
    ResolvePlayerSupervisionRequestMutationVariables
  >(ResolvePlayerSupervisionRequestDocument, options);
}
export type ResolvePlayerSupervisionRequestMutationHookResult = ReturnType<
  typeof useResolvePlayerSupervisionRequestMutation
>;
export type ResolvePlayerSupervisionRequestMutationResult =
  Apollo.MutationResult<ResolvePlayerSupervisionRequestMutation>;
export type ResolvePlayerSupervisionRequestMutationOptions =
  Apollo.BaseMutationOptions<
    ResolvePlayerSupervisionRequestMutation,
    ResolvePlayerSupervisionRequestMutationVariables
  >;
export const UpdateUserDocument = gql`
  mutation UpdateUser($id: ID!, $input: UpdateUserInput!) {
    updateUser(id: $id, input: $input) {
      id
    }
  }
`;
export type UpdateUserMutationFn = Apollo.MutationFunction<
  UpdateUserMutation,
  UpdateUserMutationVariables
>;

/**
 * __useUpdateUserMutation__
 *
 * To run a mutation, you first call `useUpdateUserMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateUserMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateUserMutation, { data, loading, error }] = useUpdateUserMutation({
 *   variables: {
 *      id: // value for 'id'
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateUserMutation(
  baseOptions?: Apollo.MutationHookOptions<
    UpdateUserMutation,
    UpdateUserMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useMutation<UpdateUserMutation, UpdateUserMutationVariables>(
    UpdateUserDocument,
    options
  );
}
export type UpdateUserMutationHookResult = ReturnType<
  typeof useUpdateUserMutation
>;
export type UpdateUserMutationResult =
  Apollo.MutationResult<UpdateUserMutation>;
export type UpdateUserMutationOptions = Apollo.BaseMutationOptions<
  UpdateUserMutation,
  UpdateUserMutationVariables
>;
export const GroupDocument = gql`
  query Group($id: ID!) {
    node(id: $id) {
      ...groupFields
    }
  }
  ${GroupFieldsFragmentDoc}
`;

/**
 * __useGroupQuery__
 *
 * To run a query within a React component, call `useGroupQuery` and pass it any options that fit your needs.
 * When your component renders, `useGroupQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGroupQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGroupQuery(
  baseOptions: Apollo.QueryHookOptions<GroupQuery, GroupQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<GroupQuery, GroupQueryVariables>(
    GroupDocument,
    options
  );
}
export function useGroupLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<GroupQuery, GroupQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<GroupQuery, GroupQueryVariables>(
    GroupDocument,
    options
  );
}
export type GroupQueryHookResult = ReturnType<typeof useGroupQuery>;
export type GroupLazyQueryHookResult = ReturnType<typeof useGroupLazyQuery>;
export type GroupQueryResult = Apollo.QueryResult<
  GroupQuery,
  GroupQueryVariables
>;
export const GroupApplicationsDocument = gql`
  query GroupApplications($id: ID!) {
    node(id: $id) {
      ... on Group {
        applications {
          id
          message
          user {
            ...userFields
          }
        }
      }
    }
  }
  ${UserFieldsFragmentDoc}
`;

/**
 * __useGroupApplicationsQuery__
 *
 * To run a query within a React component, call `useGroupApplicationsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGroupApplicationsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGroupApplicationsQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGroupApplicationsQuery(
  baseOptions: Apollo.QueryHookOptions<
    GroupApplicationsQuery,
    GroupApplicationsQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<
    GroupApplicationsQuery,
    GroupApplicationsQueryVariables
  >(GroupApplicationsDocument, options);
}
export function useGroupApplicationsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GroupApplicationsQuery,
    GroupApplicationsQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<
    GroupApplicationsQuery,
    GroupApplicationsQueryVariables
  >(GroupApplicationsDocument, options);
}
export type GroupApplicationsQueryHookResult = ReturnType<
  typeof useGroupApplicationsQuery
>;
export type GroupApplicationsLazyQueryHookResult = ReturnType<
  typeof useGroupApplicationsLazyQuery
>;
export type GroupApplicationsQueryResult = Apollo.QueryResult<
  GroupApplicationsQuery,
  GroupApplicationsQueryVariables
>;
export const GroupMembersDocument = gql`
  query GroupMembers(
    $groupId: ID!
    $before: Cursor
    $after: Cursor
    $first: Int
    $last: Int
    $where: GroupMembershipWhereInput
  ) {
    node(id: $groupId) {
      ... on Group {
        members(
          before: $before
          after: $after
          first: $first
          last: $last
          where: $where
        ) {
          totalCount
          pageInfo {
            ...pageInfoFields
          }
          edges {
            node {
              ...groupMembershipFields
            }
          }
        }
      }
    }
  }
  ${PageInfoFieldsFragmentDoc}
  ${GroupMembershipFieldsFragmentDoc}
`;

/**
 * __useGroupMembersQuery__
 *
 * To run a query within a React component, call `useGroupMembersQuery` and pass it any options that fit your needs.
 * When your component renders, `useGroupMembersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGroupMembersQuery({
 *   variables: {
 *      groupId: // value for 'groupId'
 *      before: // value for 'before'
 *      after: // value for 'after'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *      where: // value for 'where'
 *   },
 * });
 */
export function useGroupMembersQuery(
  baseOptions: Apollo.QueryHookOptions<
    GroupMembersQuery,
    GroupMembersQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<GroupMembersQuery, GroupMembersQueryVariables>(
    GroupMembersDocument,
    options
  );
}
export function useGroupMembersLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GroupMembersQuery,
    GroupMembersQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<GroupMembersQuery, GroupMembersQueryVariables>(
    GroupMembersDocument,
    options
  );
}
export type GroupMembersQueryHookResult = ReturnType<
  typeof useGroupMembersQuery
>;
export type GroupMembersLazyQueryHookResult = ReturnType<
  typeof useGroupMembersLazyQuery
>;
export type GroupMembersQueryResult = Apollo.QueryResult<
  GroupMembersQuery,
  GroupMembersQueryVariables
>;
export const GroupSettingsDocument = gql`
  query GroupSettings($id: ID!) {
    node(id: $id) {
      ... on Group {
        id
        name
        description
        logoURL
        settings {
          id
          visibility
          joinPolicy
          minimumRoleToInvite
        }
      }
    }
  }
`;

/**
 * __useGroupSettingsQuery__
 *
 * To run a query within a React component, call `useGroupSettingsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGroupSettingsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGroupSettingsQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGroupSettingsQuery(
  baseOptions: Apollo.QueryHookOptions<
    GroupSettingsQuery,
    GroupSettingsQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<GroupSettingsQuery, GroupSettingsQueryVariables>(
    GroupSettingsDocument,
    options
  );
}
export function useGroupSettingsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GroupSettingsQuery,
    GroupSettingsQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<GroupSettingsQuery, GroupSettingsQueryVariables>(
    GroupSettingsDocument,
    options
  );
}
export type GroupSettingsQueryHookResult = ReturnType<
  typeof useGroupSettingsQuery
>;
export type GroupSettingsLazyQueryHookResult = ReturnType<
  typeof useGroupSettingsLazyQuery
>;
export type GroupSettingsQueryResult = Apollo.QueryResult<
  GroupSettingsQuery,
  GroupSettingsQueryVariables
>;
export const IncomingSupervisionRequestsDocument = gql`
  query IncomingSupervisionRequests {
    me {
      receivedSupervisionRequests {
        ...playerSupervisionRequestFields
      }
    }
  }
  ${PlayerSupervisionRequestFieldsFragmentDoc}
`;

/**
 * __useIncomingSupervisionRequestsQuery__
 *
 * To run a query within a React component, call `useIncomingSupervisionRequestsQuery` and pass it any options that fit your needs.
 * When your component renders, `useIncomingSupervisionRequestsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useIncomingSupervisionRequestsQuery({
 *   variables: {
 *   },
 * });
 */
export function useIncomingSupervisionRequestsQuery(
  baseOptions?: Apollo.QueryHookOptions<
    IncomingSupervisionRequestsQuery,
    IncomingSupervisionRequestsQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<
    IncomingSupervisionRequestsQuery,
    IncomingSupervisionRequestsQueryVariables
  >(IncomingSupervisionRequestsDocument, options);
}
export function useIncomingSupervisionRequestsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    IncomingSupervisionRequestsQuery,
    IncomingSupervisionRequestsQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<
    IncomingSupervisionRequestsQuery,
    IncomingSupervisionRequestsQueryVariables
  >(IncomingSupervisionRequestsDocument, options);
}
export type IncomingSupervisionRequestsQueryHookResult = ReturnType<
  typeof useIncomingSupervisionRequestsQuery
>;
export type IncomingSupervisionRequestsLazyQueryHookResult = ReturnType<
  typeof useIncomingSupervisionRequestsLazyQuery
>;
export type IncomingSupervisionRequestsQueryResult = Apollo.QueryResult<
  IncomingSupervisionRequestsQuery,
  IncomingSupervisionRequestsQueryVariables
>;
export const MatchDocument = gql`
  query Match($id: ID!) {
    node(id: $id) {
      ...matchFields
    }
  }
  ${MatchFieldsFragmentDoc}
`;

/**
 * __useMatchQuery__
 *
 * To run a query within a React component, call `useMatchQuery` and pass it any options that fit your needs.
 * When your component renders, `useMatchQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMatchQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useMatchQuery(
  baseOptions: Apollo.QueryHookOptions<MatchQuery, MatchQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<MatchQuery, MatchQueryVariables>(
    MatchDocument,
    options
  );
}
export function useMatchLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<MatchQuery, MatchQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<MatchQuery, MatchQueryVariables>(
    MatchDocument,
    options
  );
}
export type MatchQueryHookResult = ReturnType<typeof useMatchQuery>;
export type MatchLazyQueryHookResult = ReturnType<typeof useMatchLazyQuery>;
export type MatchQueryResult = Apollo.QueryResult<
  MatchQuery,
  MatchQueryVariables
>;
export const MeDocument = gql`
  query Me {
    me {
      ...userFields
    }
  }
  ${UserFieldsFragmentDoc}
`;

/**
 * __useMeQuery__
 *
 * To run a query within a React component, call `useMeQuery` and pass it any options that fit your needs.
 * When your component renders, `useMeQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMeQuery({
 *   variables: {
 *   },
 * });
 */
export function useMeQuery(
  baseOptions?: Apollo.QueryHookOptions<MeQuery, MeQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<MeQuery, MeQueryVariables>(MeDocument, options);
}
export function useMeLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<MeQuery, MeQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<MeQuery, MeQueryVariables>(MeDocument, options);
}
export type MeQueryHookResult = ReturnType<typeof useMeQuery>;
export type MeLazyQueryHookResult = ReturnType<typeof useMeLazyQuery>;
export type MeQueryResult = Apollo.QueryResult<MeQuery, MeQueryVariables>;
export const MyPlayersDocument = gql`
  query MyPlayers {
    me {
      players {
        ...playerFields
      }
    }
  }
  ${PlayerFieldsFragmentDoc}
`;

/**
 * __useMyPlayersQuery__
 *
 * To run a query within a React component, call `useMyPlayersQuery` and pass it any options that fit your needs.
 * When your component renders, `useMyPlayersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMyPlayersQuery({
 *   variables: {
 *   },
 * });
 */
export function useMyPlayersQuery(
  baseOptions?: Apollo.QueryHookOptions<MyPlayersQuery, MyPlayersQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<MyPlayersQuery, MyPlayersQueryVariables>(
    MyPlayersDocument,
    options
  );
}
export function useMyPlayersLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    MyPlayersQuery,
    MyPlayersQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<MyPlayersQuery, MyPlayersQueryVariables>(
    MyPlayersDocument,
    options
  );
}
export type MyPlayersQueryHookResult = ReturnType<typeof useMyPlayersQuery>;
export type MyPlayersLazyQueryHookResult = ReturnType<
  typeof useMyPlayersLazyQuery
>;
export type MyPlayersQueryResult = Apollo.QueryResult<
  MyPlayersQuery,
  MyPlayersQueryVariables
>;
export const PendingSupervisionRequestsDocument = gql`
  query PendingSupervisionRequests {
    me {
      sentSupervisionRequests {
        ...playerSupervisionRequestFields
      }
    }
  }
  ${PlayerSupervisionRequestFieldsFragmentDoc}
`;

/**
 * __usePendingSupervisionRequestsQuery__
 *
 * To run a query within a React component, call `usePendingSupervisionRequestsQuery` and pass it any options that fit your needs.
 * When your component renders, `usePendingSupervisionRequestsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePendingSupervisionRequestsQuery({
 *   variables: {
 *   },
 * });
 */
export function usePendingSupervisionRequestsQuery(
  baseOptions?: Apollo.QueryHookOptions<
    PendingSupervisionRequestsQuery,
    PendingSupervisionRequestsQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<
    PendingSupervisionRequestsQuery,
    PendingSupervisionRequestsQueryVariables
  >(PendingSupervisionRequestsDocument, options);
}
export function usePendingSupervisionRequestsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    PendingSupervisionRequestsQuery,
    PendingSupervisionRequestsQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<
    PendingSupervisionRequestsQuery,
    PendingSupervisionRequestsQueryVariables
  >(PendingSupervisionRequestsDocument, options);
}
export type PendingSupervisionRequestsQueryHookResult = ReturnType<
  typeof usePendingSupervisionRequestsQuery
>;
export type PendingSupervisionRequestsLazyQueryHookResult = ReturnType<
  typeof usePendingSupervisionRequestsLazyQuery
>;
export type PendingSupervisionRequestsQueryResult = Apollo.QueryResult<
  PendingSupervisionRequestsQuery,
  PendingSupervisionRequestsQueryVariables
>;
export const PresignUploadUrlDocument = gql`
  query PresignUploadURL {
    preSignUploadURL {
      url
      headers {
        key
        value
      }
    }
  }
`;

/**
 * __usePresignUploadUrlQuery__
 *
 * To run a query within a React component, call `usePresignUploadUrlQuery` and pass it any options that fit your needs.
 * When your component renders, `usePresignUploadUrlQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePresignUploadUrlQuery({
 *   variables: {
 *   },
 * });
 */
export function usePresignUploadUrlQuery(
  baseOptions?: Apollo.QueryHookOptions<
    PresignUploadUrlQuery,
    PresignUploadUrlQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<PresignUploadUrlQuery, PresignUploadUrlQueryVariables>(
    PresignUploadUrlDocument,
    options
  );
}
export function usePresignUploadUrlLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    PresignUploadUrlQuery,
    PresignUploadUrlQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<
    PresignUploadUrlQuery,
    PresignUploadUrlQueryVariables
  >(PresignUploadUrlDocument, options);
}
export type PresignUploadUrlQueryHookResult = ReturnType<
  typeof usePresignUploadUrlQuery
>;
export type PresignUploadUrlLazyQueryHookResult = ReturnType<
  typeof usePresignUploadUrlLazyQuery
>;
export type PresignUploadUrlQueryResult = Apollo.QueryResult<
  PresignUploadUrlQuery,
  PresignUploadUrlQueryVariables
>;
export const SearchGamesDocument = gql`
  query SearchGames(
    $before: Cursor
    $after: Cursor
    $where: GameWhereInput!
    $first: Int
    $last: Int
  ) {
    games(
      before: $before
      after: $after
      where: $where
      first: $first
      last: $last
    ) {
      pageInfo {
        ...pageInfoFields
      }
      totalCount
      edges {
        node {
          ...gameFields
        }
      }
    }
  }
  ${PageInfoFieldsFragmentDoc}
  ${GameFieldsFragmentDoc}
`;

/**
 * __useSearchGamesQuery__
 *
 * To run a query within a React component, call `useSearchGamesQuery` and pass it any options that fit your needs.
 * When your component renders, `useSearchGamesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSearchGamesQuery({
 *   variables: {
 *      before: // value for 'before'
 *      after: // value for 'after'
 *      where: // value for 'where'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useSearchGamesQuery(
  baseOptions: Apollo.QueryHookOptions<
    SearchGamesQuery,
    SearchGamesQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<SearchGamesQuery, SearchGamesQueryVariables>(
    SearchGamesDocument,
    options
  );
}
export function useSearchGamesLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    SearchGamesQuery,
    SearchGamesQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<SearchGamesQuery, SearchGamesQueryVariables>(
    SearchGamesDocument,
    options
  );
}
export type SearchGamesQueryHookResult = ReturnType<typeof useSearchGamesQuery>;
export type SearchGamesLazyQueryHookResult = ReturnType<
  typeof useSearchGamesLazyQuery
>;
export type SearchGamesQueryResult = Apollo.QueryResult<
  SearchGamesQuery,
  SearchGamesQueryVariables
>;
export const SearchGroupsDocument = gql`
  query SearchGroups(
    $before: Cursor
    $after: Cursor
    $where: GroupWhereInput!
    $first: Int
    $last: Int
  ) {
    groups(
      before: $before
      after: $after
      where: $where
      first: $first
      last: $last
    ) {
      pageInfo {
        ...pageInfoFields
      }
      totalCount
      edges {
        node {
          ...groupFields
        }
      }
    }
  }
  ${PageInfoFieldsFragmentDoc}
  ${GroupFieldsFragmentDoc}
`;

/**
 * __useSearchGroupsQuery__
 *
 * To run a query within a React component, call `useSearchGroupsQuery` and pass it any options that fit your needs.
 * When your component renders, `useSearchGroupsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSearchGroupsQuery({
 *   variables: {
 *      before: // value for 'before'
 *      after: // value for 'after'
 *      where: // value for 'where'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useSearchGroupsQuery(
  baseOptions: Apollo.QueryHookOptions<
    SearchGroupsQuery,
    SearchGroupsQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<SearchGroupsQuery, SearchGroupsQueryVariables>(
    SearchGroupsDocument,
    options
  );
}
export function useSearchGroupsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    SearchGroupsQuery,
    SearchGroupsQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<SearchGroupsQuery, SearchGroupsQueryVariables>(
    SearchGroupsDocument,
    options
  );
}
export type SearchGroupsQueryHookResult = ReturnType<
  typeof useSearchGroupsQuery
>;
export type SearchGroupsLazyQueryHookResult = ReturnType<
  typeof useSearchGroupsLazyQuery
>;
export type SearchGroupsQueryResult = Apollo.QueryResult<
  SearchGroupsQuery,
  SearchGroupsQueryVariables
>;
export const SearchMatchesDocument = gql`
  query SearchMatches(
    $before: Cursor
    $after: Cursor
    $where: MatchWhereInput!
    $first: Int
    $last: Int
  ) {
    matches(
      before: $before
      after: $after
      where: $where
      first: $first
      last: $last
    ) {
      pageInfo {
        ...pageInfoFields
      }
      totalCount
      edges {
        node {
          ...matchFields
        }
      }
    }
  }
  ${PageInfoFieldsFragmentDoc}
  ${MatchFieldsFragmentDoc}
`;

/**
 * __useSearchMatchesQuery__
 *
 * To run a query within a React component, call `useSearchMatchesQuery` and pass it any options that fit your needs.
 * When your component renders, `useSearchMatchesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSearchMatchesQuery({
 *   variables: {
 *      before: // value for 'before'
 *      after: // value for 'after'
 *      where: // value for 'where'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useSearchMatchesQuery(
  baseOptions: Apollo.QueryHookOptions<
    SearchMatchesQuery,
    SearchMatchesQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<SearchMatchesQuery, SearchMatchesQueryVariables>(
    SearchMatchesDocument,
    options
  );
}
export function useSearchMatchesLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    SearchMatchesQuery,
    SearchMatchesQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<SearchMatchesQuery, SearchMatchesQueryVariables>(
    SearchMatchesDocument,
    options
  );
}
export type SearchMatchesQueryHookResult = ReturnType<
  typeof useSearchMatchesQuery
>;
export type SearchMatchesLazyQueryHookResult = ReturnType<
  typeof useSearchMatchesLazyQuery
>;
export type SearchMatchesQueryResult = Apollo.QueryResult<
  SearchMatchesQuery,
  SearchMatchesQueryVariables
>;
export const SearchPlayersDocument = gql`
  query SearchPlayers(
    $before: Cursor
    $after: Cursor
    $where: PlayerWhereInput!
    $first: Int
    $last: Int
  ) {
    players(
      before: $before
      after: $after
      where: $where
      first: $first
      last: $last
    ) {
      pageInfo {
        ...pageInfoFields
      }
      totalCount
      edges {
        cursor
        node {
          ...playerFields
        }
      }
    }
  }
  ${PageInfoFieldsFragmentDoc}
  ${PlayerFieldsFragmentDoc}
`;

/**
 * __useSearchPlayersQuery__
 *
 * To run a query within a React component, call `useSearchPlayersQuery` and pass it any options that fit your needs.
 * When your component renders, `useSearchPlayersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSearchPlayersQuery({
 *   variables: {
 *      before: // value for 'before'
 *      after: // value for 'after'
 *      where: // value for 'where'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useSearchPlayersQuery(
  baseOptions: Apollo.QueryHookOptions<
    SearchPlayersQuery,
    SearchPlayersQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<SearchPlayersQuery, SearchPlayersQueryVariables>(
    SearchPlayersDocument,
    options
  );
}
export function useSearchPlayersLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    SearchPlayersQuery,
    SearchPlayersQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<SearchPlayersQuery, SearchPlayersQueryVariables>(
    SearchPlayersDocument,
    options
  );
}
export type SearchPlayersQueryHookResult = ReturnType<
  typeof useSearchPlayersQuery
>;
export type SearchPlayersLazyQueryHookResult = ReturnType<
  typeof useSearchPlayersLazyQuery
>;
export type SearchPlayersQueryResult = Apollo.QueryResult<
  SearchPlayersQuery,
  SearchPlayersQueryVariables
>;
export type WithIndex<TObject> = TObject & Record<string, any>;
export type ResolversObject<TObject> = WithIndex<TObject>;

export type ResolverTypeWrapper<T> = Promise<T> | T;

export type ResolverWithResolve<TResult, TParent, TContext, TArgs> = {
  resolve: ResolverFn<TResult, TParent, TContext, TArgs>;
};
export type Resolver<TResult, TParent = {}, TContext = {}, TArgs = {}> =
  | ResolverFn<TResult, TParent, TContext, TArgs>
  | ResolverWithResolve<TResult, TParent, TContext, TArgs>;

export type ResolverFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => Promise<TResult> | TResult;

export type SubscriptionSubscribeFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => AsyncIterable<TResult> | Promise<AsyncIterable<TResult>>;

export type SubscriptionResolveFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => TResult | Promise<TResult>;

export interface SubscriptionSubscriberObject<
  TResult,
  TKey extends string,
  TParent,
  TContext,
  TArgs
> {
  subscribe: SubscriptionSubscribeFn<
    { [key in TKey]: TResult },
    TParent,
    TContext,
    TArgs
  >;
  resolve?: SubscriptionResolveFn<
    TResult,
    { [key in TKey]: TResult },
    TContext,
    TArgs
  >;
}

export interface SubscriptionResolverObject<TResult, TParent, TContext, TArgs> {
  subscribe: SubscriptionSubscribeFn<any, TParent, TContext, TArgs>;
  resolve: SubscriptionResolveFn<TResult, any, TContext, TArgs>;
}

export type SubscriptionObject<
  TResult,
  TKey extends string,
  TParent,
  TContext,
  TArgs
> =
  | SubscriptionSubscriberObject<TResult, TKey, TParent, TContext, TArgs>
  | SubscriptionResolverObject<TResult, TParent, TContext, TArgs>;

export type SubscriptionResolver<
  TResult,
  TKey extends string,
  TParent = {},
  TContext = {},
  TArgs = {}
> =
  | ((
      ...args: any[]
    ) => SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>)
  | SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>;

export type TypeResolveFn<TTypes, TParent = {}, TContext = {}> = (
  parent: TParent,
  context: TContext,
  info: GraphQLResolveInfo
) => Maybe<TTypes> | Promise<Maybe<TTypes>>;

export type IsTypeOfResolverFn<T = {}, TContext = {}> = (
  obj: T,
  context: TContext,
  info: GraphQLResolveInfo
) => boolean | Promise<boolean>;

export type NextResolverFn<T> = () => Promise<T>;

export type DirectiveResolverFn<
  TResult = {},
  TParent = {},
  TContext = {},
  TArgs = {}
> = (
  next: NextResolverFn<TResult>,
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => TResult | Promise<TResult>;

/** Mapping between all available schema types and the resolvers types */
export type ResolversTypes = ResolversObject<{
  AggregateMetadata: ResolverTypeWrapper<AggregateMetadata>;
  AggregateMetadataInput: AggregateMetadataInput;
  AggregateMetadataType: AggregateMetadataType;
  Boolean: ResolverTypeWrapper<Scalars["Boolean"]>;
  CreateGameInput: CreateGameInput;
  CreateMatchInput: CreateMatchInput;
  CreateOrUpdateGroupInput: CreateOrUpdateGroupInput;
  CreatePlayerInput: CreatePlayerInput;
  Cursor: ResolverTypeWrapper<Scalars["Cursor"]>;
  EnumMetadata: ResolverTypeWrapper<EnumMetadata>;
  EnumMetadataInput: EnumMetadataInput;
  EnumMetric: ResolverTypeWrapper<EnumMetric>;
  EnumOccurences: ResolverTypeWrapper<EnumOccurences>;
  Favorites: ResolverTypeWrapper<Favorites>;
  Float: ResolverTypeWrapper<Scalars["Float"]>;
  Game: ResolverTypeWrapper<Game>;
  GameConnection: ResolverTypeWrapper<GameConnection>;
  GameEdge: ResolverTypeWrapper<GameEdge>;
  GameVersion: ResolverTypeWrapper<GameVersion>;
  GameVersionMetrics: ResolverTypeWrapper<GameVersionMetrics>;
  GameVersionWhereInput: GameVersionWhereInput;
  GameWhereInput: GameWhereInput;
  Granularity: Granularity;
  GranularityInput: GranularityInput;
  Group: ResolverTypeWrapper<Group>;
  GroupApplicationInput: GroupApplicationInput;
  GroupConnection: ResolverTypeWrapper<GroupConnection>;
  GroupEdge: ResolverTypeWrapper<GroupEdge>;
  GroupMembership: ResolverTypeWrapper<GroupMembership>;
  GroupMembershipApplication: ResolverTypeWrapper<GroupMembershipApplication>;
  GroupMembershipConnection: ResolverTypeWrapper<GroupMembershipConnection>;
  GroupMembershipEdge: ResolverTypeWrapper<GroupMembershipEdge>;
  GroupMembershipRole: GroupMembershipRole;
  GroupMembershipWhereInput: GroupMembershipWhereInput;
  GroupSettings: ResolverTypeWrapper<GroupSettings>;
  GroupSettingsInput: GroupSettingsInput;
  GroupSettingsJoinPolicy: GroupSettingsJoinPolicy;
  GroupSettingsVisibility: GroupSettingsVisibility;
  GroupSettingsWhereInput: GroupSettingsWhereInput;
  GroupWhereInput: GroupWhereInput;
  Header: ResolverTypeWrapper<Header>;
  ID: ResolverTypeWrapper<Scalars["ID"]>;
  Int: ResolverTypeWrapper<Scalars["Int"]>;
  Match: ResolverTypeWrapper<Match>;
  MatchConnection: ResolverTypeWrapper<MatchConnection>;
  MatchEdge: ResolverTypeWrapper<MatchEdge>;
  MatchWhereInput: MatchWhereInput;
  Mutation: ResolverTypeWrapper<{}>;
  Node:
    | ResolversTypes["Game"]
    | ResolversTypes["GameVersion"]
    | ResolversTypes["Group"]
    | ResolversTypes["GroupMembership"]
    | ResolversTypes["GroupMembershipApplication"]
    | ResolversTypes["GroupSettings"]
    | ResolversTypes["Match"]
    | ResolversTypes["Player"]
    | ResolversTypes["PlayerSupervisionRequest"]
    | ResolversTypes["PlayerSupervisionRequestApproval"]
    | ResolversTypes["StatDescription"]
    | ResolversTypes["Statistic"]
    | ResolversTypes["User"];
  NumericMetric: ResolverTypeWrapper<NumericMetric>;
  OrderDirection: OrderDirection;
  PageInfo: ResolverTypeWrapper<PageInfo>;
  Player: ResolverTypeWrapper<Player>;
  PlayerConnection: ResolverTypeWrapper<PlayerConnection>;
  PlayerEdge: ResolverTypeWrapper<PlayerEdge>;
  PlayerSupervisionRequest: ResolverTypeWrapper<PlayerSupervisionRequest>;
  PlayerSupervisionRequestApproval: ResolverTypeWrapper<PlayerSupervisionRequestApproval>;
  PlayerSupervisionRequestApprovalWhereInput: PlayerSupervisionRequestApprovalWhereInput;
  PlayerSupervisionRequestWhereInput: PlayerSupervisionRequestWhereInput;
  PlayerWhereInput: PlayerWhereInput;
  Query: ResolverTypeWrapper<{}>;
  RequestPlayerSupervisionInput: RequestPlayerSupervisionInput;
  ResolvePlayerSupervisionRequestInput: ResolvePlayerSupervisionRequestInput;
  StatDescription: ResolverTypeWrapper<StatDescription>;
  StatDescriptionInput: StatDescriptionInput;
  StatDescriptionStatType: StatDescriptionStatType;
  StatInput: StatInput;
  StatMetadataInput: StatMetadataInput;
  Statistic: ResolverTypeWrapper<Statistic>;
  String: ResolverTypeWrapper<Scalars["String"]>;
  Time: ResolverTypeWrapper<Scalars["Time"]>;
  TimeFloatMetric: ResolverTypeWrapper<TimeFloatMetric>;
  TimeSeries: ResolverTypeWrapper<TimeSeries>;
  TimeSeriesInput: TimeSeriesInput;
  TimeSeriesPeriod: ResolverTypeWrapper<TimeSeriesPeriod>;
  UpdateUserInput: UpdateUserInput;
  UploadURL: ResolverTypeWrapper<UploadUrl>;
  User: ResolverTypeWrapper<User>;
  UserConnection: ResolverTypeWrapper<UserConnection>;
  UserEdge: ResolverTypeWrapper<UserEdge>;
  UserWhereInput: UserWhereInput;
}>;

/** Mapping between all available schema types and the resolvers parents */
export type ResolversParentTypes = ResolversObject<{
  AggregateMetadata: AggregateMetadata;
  AggregateMetadataInput: AggregateMetadataInput;
  Boolean: Scalars["Boolean"];
  CreateGameInput: CreateGameInput;
  CreateMatchInput: CreateMatchInput;
  CreateOrUpdateGroupInput: CreateOrUpdateGroupInput;
  CreatePlayerInput: CreatePlayerInput;
  Cursor: Scalars["Cursor"];
  EnumMetadata: EnumMetadata;
  EnumMetadataInput: EnumMetadataInput;
  EnumMetric: EnumMetric;
  EnumOccurences: EnumOccurences;
  Favorites: Favorites;
  Float: Scalars["Float"];
  Game: Game;
  GameConnection: GameConnection;
  GameEdge: GameEdge;
  GameVersion: GameVersion;
  GameVersionMetrics: GameVersionMetrics;
  GameVersionWhereInput: GameVersionWhereInput;
  GameWhereInput: GameWhereInput;
  GranularityInput: GranularityInput;
  Group: Group;
  GroupApplicationInput: GroupApplicationInput;
  GroupConnection: GroupConnection;
  GroupEdge: GroupEdge;
  GroupMembership: GroupMembership;
  GroupMembershipApplication: GroupMembershipApplication;
  GroupMembershipConnection: GroupMembershipConnection;
  GroupMembershipEdge: GroupMembershipEdge;
  GroupMembershipWhereInput: GroupMembershipWhereInput;
  GroupSettings: GroupSettings;
  GroupSettingsInput: GroupSettingsInput;
  GroupSettingsWhereInput: GroupSettingsWhereInput;
  GroupWhereInput: GroupWhereInput;
  Header: Header;
  ID: Scalars["ID"];
  Int: Scalars["Int"];
  Match: Match;
  MatchConnection: MatchConnection;
  MatchEdge: MatchEdge;
  MatchWhereInput: MatchWhereInput;
  Mutation: {};
  Node:
    | ResolversParentTypes["Game"]
    | ResolversParentTypes["GameVersion"]
    | ResolversParentTypes["Group"]
    | ResolversParentTypes["GroupMembership"]
    | ResolversParentTypes["GroupMembershipApplication"]
    | ResolversParentTypes["GroupSettings"]
    | ResolversParentTypes["Match"]
    | ResolversParentTypes["Player"]
    | ResolversParentTypes["PlayerSupervisionRequest"]
    | ResolversParentTypes["PlayerSupervisionRequestApproval"]
    | ResolversParentTypes["StatDescription"]
    | ResolversParentTypes["Statistic"]
    | ResolversParentTypes["User"];
  NumericMetric: NumericMetric;
  PageInfo: PageInfo;
  Player: Player;
  PlayerConnection: PlayerConnection;
  PlayerEdge: PlayerEdge;
  PlayerSupervisionRequest: PlayerSupervisionRequest;
  PlayerSupervisionRequestApproval: PlayerSupervisionRequestApproval;
  PlayerSupervisionRequestApprovalWhereInput: PlayerSupervisionRequestApprovalWhereInput;
  PlayerSupervisionRequestWhereInput: PlayerSupervisionRequestWhereInput;
  PlayerWhereInput: PlayerWhereInput;
  Query: {};
  RequestPlayerSupervisionInput: RequestPlayerSupervisionInput;
  ResolvePlayerSupervisionRequestInput: ResolvePlayerSupervisionRequestInput;
  StatDescription: StatDescription;
  StatDescriptionInput: StatDescriptionInput;
  StatInput: StatInput;
  StatMetadataInput: StatMetadataInput;
  Statistic: Statistic;
  String: Scalars["String"];
  Time: Scalars["Time"];
  TimeFloatMetric: TimeFloatMetric;
  TimeSeries: TimeSeries;
  TimeSeriesInput: TimeSeriesInput;
  TimeSeriesPeriod: TimeSeriesPeriod;
  UpdateUserInput: UpdateUserInput;
  UploadURL: UploadUrl;
  User: User;
  UserConnection: UserConnection;
  UserEdge: UserEdge;
  UserWhereInput: UserWhereInput;
}>;

export type AuthenticatedDirectiveArgs = {};

export type AuthenticatedDirectiveResolver<
  Result,
  Parent,
  ContextType = any,
  Args = AuthenticatedDirectiveArgs
> = DirectiveResolverFn<Result, Parent, ContextType, Args>;

export type DeferDirectiveArgs = {
  if?: Maybe<Scalars["Boolean"]>;
  label?: Maybe<Scalars["String"]>;
};

export type DeferDirectiveResolver<
  Result,
  Parent,
  ContextType = any,
  Args = DeferDirectiveArgs
> = DirectiveResolverFn<Result, Parent, ContextType, Args>;

export type GoFieldDirectiveArgs = {
  forceResolver?: Maybe<Scalars["Boolean"]>;
  name?: Maybe<Scalars["String"]>;
  omittable?: Maybe<Scalars["Boolean"]>;
};

export type GoFieldDirectiveResolver<
  Result,
  Parent,
  ContextType = any,
  Args = GoFieldDirectiveArgs
> = DirectiveResolverFn<Result, Parent, ContextType, Args>;

export type GoModelDirectiveArgs = {
  forceGenerate?: Maybe<Scalars["Boolean"]>;
  model?: Maybe<Scalars["String"]>;
  models?: Maybe<Array<Scalars["String"]>>;
};

export type GoModelDirectiveResolver<
  Result,
  Parent,
  ContextType = any,
  Args = GoModelDirectiveArgs
> = DirectiveResolverFn<Result, Parent, ContextType, Args>;

export type AggregateMetadataResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["AggregateMetadata"] = ResolversParentTypes["AggregateMetadata"]
> = ResolversObject<{
  statIds?: Resolver<Array<ResolversTypes["ID"]>, ParentType, ContextType>;
  type?: Resolver<
    ResolversTypes["AggregateMetadataType"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface CursorScalarConfig
  extends GraphQLScalarTypeConfig<ResolversTypes["Cursor"], any> {
  name: "Cursor";
}

export type EnumMetadataResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["EnumMetadata"] = ResolversParentTypes["EnumMetadata"]
> = ResolversObject<{
  possibleValues?: Resolver<
    Array<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EnumMetricResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["EnumMetric"] = ResolversParentTypes["EnumMetric"]
> = ResolversObject<{
  global?: Resolver<
    Array<ResolversTypes["EnumOccurences"]>,
    ParentType,
    ContextType
  >;
  stat?: Resolver<ResolversTypes["StatDescription"], ParentType, ContextType>;
  user?: Resolver<
    Maybe<Array<ResolversTypes["EnumOccurences"]>>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type EnumOccurencesResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["EnumOccurences"] = ResolversParentTypes["EnumOccurences"]
> = ResolversObject<{
  occurences?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  value?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type FavoritesResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["Favorites"] = ResolversParentTypes["Favorites"]
> = ResolversObject<{
  total?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  users?: Resolver<Array<ResolversTypes["User"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GameResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["Game"] = ResolversParentTypes["Game"]
> = ResolversObject<{
  author?: Resolver<ResolversTypes["User"], ParentType, ContextType>;
  boardgamegeekURL?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  description?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  favorites?: Resolver<ResolversTypes["Favorites"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  isFavorite?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  maxPlayers?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  minPlayers?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  versions?: Resolver<
    Array<ResolversTypes["GameVersion"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GameConnectionResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["GameConnection"] = ResolversParentTypes["GameConnection"]
> = ResolversObject<{
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["GameEdge"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GameEdgeResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["GameEdge"] = ResolversParentTypes["GameEdge"]
> = ResolversObject<{
  cursor?: Resolver<ResolversTypes["Cursor"], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes["Game"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GameVersionResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["GameVersion"] = ResolversParentTypes["GameVersion"]
> = ResolversObject<{
  game?: Resolver<ResolversTypes["Game"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  metrics?: Resolver<
    ResolversTypes["GameVersionMetrics"],
    ParentType,
    ContextType
  >;
  statDescriptions?: Resolver<
    Array<ResolversTypes["StatDescription"]>,
    ParentType,
    ContextType
  >;
  versionNumber?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GameVersionMetricsResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["GameVersionMetrics"] = ResolversParentTypes["GameVersionMetrics"]
> = ResolversObject<{
  adoption?: Resolver<
    ResolversTypes["TimeFloatMetric"],
    ParentType,
    ContextType,
    RequireFields<GameVersionMetricsAdoptionArgs, "input">
  >;
  enumStats?: Resolver<
    Array<ResolversTypes["EnumMetric"]>,
    ParentType,
    ContextType
  >;
  matchesCreated?: Resolver<
    ResolversTypes["TimeSeries"],
    ParentType,
    ContextType,
    RequireFields<GameVersionMetricsMatchesCreatedArgs, "input">
  >;
  numericStats?: Resolver<
    Array<ResolversTypes["NumericMetric"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GroupResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["Group"] = ResolversParentTypes["Group"]
> = ResolversObject<{
  applications?: Resolver<
    Maybe<Array<ResolversTypes["GroupMembershipApplication"]>>,
    ParentType,
    ContextType
  >;
  applied?: Resolver<Maybe<ResolversTypes["Boolean"]>, ParentType, ContextType>;
  description?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  logoURL?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  members?: Resolver<
    ResolversTypes["GroupMembershipConnection"],
    ParentType,
    ContextType,
    Partial<GroupMembersArgs>
  >;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  role?: Resolver<
    Maybe<ResolversTypes["GroupMembershipRole"]>,
    ParentType,
    ContextType
  >;
  settings?: Resolver<ResolversTypes["GroupSettings"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GroupConnectionResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["GroupConnection"] = ResolversParentTypes["GroupConnection"]
> = ResolversObject<{
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["GroupEdge"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GroupEdgeResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["GroupEdge"] = ResolversParentTypes["GroupEdge"]
> = ResolversObject<{
  cursor?: Resolver<ResolversTypes["Cursor"], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes["Group"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GroupMembershipResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["GroupMembership"] = ResolversParentTypes["GroupMembership"]
> = ResolversObject<{
  group?: Resolver<ResolversTypes["Group"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  role?: Resolver<
    ResolversTypes["GroupMembershipRole"],
    ParentType,
    ContextType
  >;
  user?: Resolver<ResolversTypes["User"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GroupMembershipApplicationResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["GroupMembershipApplication"] = ResolversParentTypes["GroupMembershipApplication"]
> = ResolversObject<{
  group?: Resolver<ResolversTypes["Group"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  message?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  user?: Resolver<ResolversTypes["User"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GroupMembershipConnectionResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["GroupMembershipConnection"] = ResolversParentTypes["GroupMembershipConnection"]
> = ResolversObject<{
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["GroupMembershipEdge"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GroupMembershipEdgeResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["GroupMembershipEdge"] = ResolversParentTypes["GroupMembershipEdge"]
> = ResolversObject<{
  cursor?: Resolver<ResolversTypes["Cursor"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["GroupMembership"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GroupSettingsResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["GroupSettings"] = ResolversParentTypes["GroupSettings"]
> = ResolversObject<{
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  joinPolicy?: Resolver<
    ResolversTypes["GroupSettingsJoinPolicy"],
    ParentType,
    ContextType
  >;
  minimumRoleToInvite?: Resolver<
    Maybe<ResolversTypes["GroupMembershipRole"]>,
    ParentType,
    ContextType
  >;
  visibility?: Resolver<
    ResolversTypes["GroupSettingsVisibility"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type HeaderResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["Header"] = ResolversParentTypes["Header"]
> = ResolversObject<{
  key?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  value?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type MatchResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["Match"] = ResolversParentTypes["Match"]
> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes["Time"], ParentType, ContextType>;
  gameVersion?: Resolver<
    ResolversTypes["GameVersion"],
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  players?: Resolver<Array<ResolversTypes["Player"]>, ParentType, ContextType>;
  stats?: Resolver<
    Maybe<Array<ResolversTypes["Statistic"]>>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type MatchConnectionResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["MatchConnection"] = ResolversParentTypes["MatchConnection"]
> = ResolversObject<{
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["MatchEdge"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type MatchEdgeResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["MatchEdge"] = ResolversParentTypes["MatchEdge"]
> = ResolversObject<{
  cursor?: Resolver<ResolversTypes["Cursor"], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes["Match"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type MutationResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["Mutation"] = ResolversParentTypes["Mutation"]
> = ResolversObject<{
  addOrRemoveGameFromFavorites?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType,
    RequireFields<
      MutationAddOrRemoveGameFromFavoritesArgs,
      "favorite" | "gameId"
    >
  >;
  applyToGroup?: Resolver<
    ResolversTypes["GroupMembershipApplication"],
    ParentType,
    ContextType,
    RequireFields<MutationApplyToGroupArgs, "input">
  >;
  changeUserGroupMembershipRole?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType,
    RequireFields<
      MutationChangeUserGroupMembershipRoleArgs,
      "groupId" | "role" | "userId"
    >
  >;
  createGame?: Resolver<
    ResolversTypes["Game"],
    ParentType,
    ContextType,
    RequireFields<MutationCreateGameArgs, "input">
  >;
  createMatch?: Resolver<
    ResolversTypes["Match"],
    ParentType,
    ContextType,
    RequireFields<MutationCreateMatchArgs, "input">
  >;
  createOrUpdateGroup?: Resolver<
    ResolversTypes["Group"],
    ParentType,
    ContextType,
    RequireFields<MutationCreateOrUpdateGroupArgs, "input">
  >;
  createPlayer?: Resolver<
    ResolversTypes["Player"],
    ParentType,
    ContextType,
    RequireFields<MutationCreatePlayerArgs, "input">
  >;
  joinGroup?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType,
    RequireFields<MutationJoinGroupArgs, "groupId">
  >;
  kickUserFromGroup?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType,
    RequireFields<MutationKickUserFromGroupArgs, "groupId" | "userId">
  >;
  requestPlayerSupervision?: Resolver<
    ResolversTypes["PlayerSupervisionRequest"],
    ParentType,
    ContextType,
    Partial<MutationRequestPlayerSupervisionArgs>
  >;
  resolveGroupMembershipApplication?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType,
    RequireFields<
      MutationResolveGroupMembershipApplicationArgs,
      "accepted" | "applicationId"
    >
  >;
  resolvePlayerSupervisionRequest?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType,
    RequireFields<MutationResolvePlayerSupervisionRequestArgs, "input">
  >;
  updateUser?: Resolver<
    ResolversTypes["User"],
    ParentType,
    ContextType,
    RequireFields<MutationUpdateUserArgs, "id" | "input">
  >;
}>;

export type NodeResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["Node"] = ResolversParentTypes["Node"]
> = ResolversObject<{
  __resolveType: TypeResolveFn<
    | "Game"
    | "GameVersion"
    | "Group"
    | "GroupMembership"
    | "GroupMembershipApplication"
    | "GroupSettings"
    | "Match"
    | "Player"
    | "PlayerSupervisionRequest"
    | "PlayerSupervisionRequestApproval"
    | "StatDescription"
    | "Statistic"
    | "User",
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
}>;

export type NumericMetricResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["NumericMetric"] = ResolversParentTypes["NumericMetric"]
> = ResolversObject<{
  globalAverage?: Resolver<ResolversTypes["Float"], ParentType, ContextType>;
  stat?: Resolver<ResolversTypes["StatDescription"], ParentType, ContextType>;
  userAverage?: Resolver<
    Maybe<ResolversTypes["Float"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PageInfoResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["PageInfo"] = ResolversParentTypes["PageInfo"]
> = ResolversObject<{
  endCursor?: Resolver<
    Maybe<ResolversTypes["Cursor"]>,
    ParentType,
    ContextType
  >;
  hasNextPage?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  hasPreviousPage?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  startCursor?: Resolver<
    Maybe<ResolversTypes["Cursor"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PlayerResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["Player"] = ResolversParentTypes["Player"]
> = ResolversObject<{
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  matches?: Resolver<
    Maybe<Array<ResolversTypes["Match"]>>,
    ParentType,
    ContextType
  >;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  owner?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  supervisionRequests?: Resolver<
    Maybe<Array<ResolversTypes["PlayerSupervisionRequest"]>>,
    ParentType,
    ContextType
  >;
  supervisors?: Resolver<
    Maybe<Array<ResolversTypes["User"]>>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PlayerConnectionResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["PlayerConnection"] = ResolversParentTypes["PlayerConnection"]
> = ResolversObject<{
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["PlayerEdge"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PlayerEdgeResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["PlayerEdge"] = ResolversParentTypes["PlayerEdge"]
> = ResolversObject<{
  cursor?: Resolver<ResolversTypes["Cursor"], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes["Player"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PlayerSupervisionRequestResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["PlayerSupervisionRequest"] = ResolversParentTypes["PlayerSupervisionRequest"]
> = ResolversObject<{
  approvals?: Resolver<
    Maybe<Array<ResolversTypes["PlayerSupervisionRequestApproval"]>>,
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  player?: Resolver<ResolversTypes["Player"], ParentType, ContextType>;
  sender?: Resolver<ResolversTypes["User"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PlayerSupervisionRequestApprovalResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["PlayerSupervisionRequestApproval"] = ResolversParentTypes["PlayerSupervisionRequestApproval"]
> = ResolversObject<{
  approved?: Resolver<
    Maybe<ResolversTypes["Boolean"]>,
    ParentType,
    ContextType
  >;
  approver?: Resolver<ResolversTypes["User"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  supervisionRequest?: Resolver<
    ResolversTypes["PlayerSupervisionRequest"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type QueryResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["Query"] = ResolversParentTypes["Query"]
> = ResolversObject<{
  games?: Resolver<
    ResolversTypes["GameConnection"],
    ParentType,
    ContextType,
    Partial<QueryGamesArgs>
  >;
  groups?: Resolver<
    ResolversTypes["GroupConnection"],
    ParentType,
    ContextType,
    Partial<QueryGroupsArgs>
  >;
  matches?: Resolver<
    ResolversTypes["MatchConnection"],
    ParentType,
    ContextType,
    Partial<QueryMatchesArgs>
  >;
  me?: Resolver<ResolversTypes["User"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["Node"]>,
    ParentType,
    ContextType,
    RequireFields<QueryNodeArgs, "id">
  >;
  nodes?: Resolver<
    Array<Maybe<ResolversTypes["Node"]>>,
    ParentType,
    ContextType,
    RequireFields<QueryNodesArgs, "ids">
  >;
  players?: Resolver<
    ResolversTypes["PlayerConnection"],
    ParentType,
    ContextType,
    Partial<QueryPlayersArgs>
  >;
  preSignUploadURL?: Resolver<
    ResolversTypes["UploadURL"],
    ParentType,
    ContextType
  >;
  users?: Resolver<
    ResolversTypes["UserConnection"],
    ParentType,
    ContextType,
    Partial<QueryUsersArgs>
  >;
}>;

export type StatDescriptionResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["StatDescription"] = ResolversParentTypes["StatDescription"]
> = ResolversObject<{
  description?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  metadata?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  orderNumber?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  type?: Resolver<
    ResolversTypes["StatDescriptionStatType"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type StatisticResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["Statistic"] = ResolversParentTypes["Statistic"]
> = ResolversObject<{
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  match?: Resolver<ResolversTypes["Match"], ParentType, ContextType>;
  player?: Resolver<ResolversTypes["Player"], ParentType, ContextType>;
  statDescription?: Resolver<
    ResolversTypes["StatDescription"],
    ParentType,
    ContextType
  >;
  value?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface TimeScalarConfig
  extends GraphQLScalarTypeConfig<ResolversTypes["Time"], any> {
  name: "Time";
}

export type TimeFloatMetricResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["TimeFloatMetric"] = ResolversParentTypes["TimeFloatMetric"]
> = ResolversObject<{
  trend?: Resolver<ResolversTypes["Float"], ParentType, ContextType>;
  value?: Resolver<ResolversTypes["Float"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type TimeSeriesResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["TimeSeries"] = ResolversParentTypes["TimeSeries"]
> = ResolversObject<{
  series?: Resolver<
    Array<ResolversTypes["TimeSeriesPeriod"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type TimeSeriesPeriodResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["TimeSeriesPeriod"] = ResolversParentTypes["TimeSeriesPeriod"]
> = ResolversObject<{
  activityCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  end?: Resolver<ResolversTypes["Time"], ParentType, ContextType>;
  start?: Resolver<ResolversTypes["Time"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UploadUrlResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["UploadURL"] = ResolversParentTypes["UploadURL"]
> = ResolversObject<{
  headers?: Resolver<Array<ResolversTypes["Header"]>, ParentType, ContextType>;
  url?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UserResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["User"] = ResolversParentTypes["User"]
> = ResolversObject<{
  avatarURL?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  email?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  games?: Resolver<
    Maybe<Array<ResolversTypes["Game"]>>,
    ParentType,
    ContextType
  >;
  groupMembershipApplications?: Resolver<
    Maybe<Array<ResolversTypes["GroupMembershipApplication"]>>,
    ParentType,
    ContextType
  >;
  groupMemberships?: Resolver<
    Maybe<Array<ResolversTypes["GroupMembership"]>>,
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  mainPlayer?: Resolver<
    Maybe<ResolversTypes["Player"]>,
    ParentType,
    ContextType
  >;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  players?: Resolver<
    Maybe<Array<ResolversTypes["Player"]>>,
    ParentType,
    ContextType
  >;
  receivedSupervisionRequests?: Resolver<
    Array<ResolversTypes["PlayerSupervisionRequest"]>,
    ParentType,
    ContextType
  >;
  sentSupervisionRequests?: Resolver<
    Array<ResolversTypes["PlayerSupervisionRequest"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UserConnectionResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["UserConnection"] = ResolversParentTypes["UserConnection"]
> = ResolversObject<{
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["UserEdge"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UserEdgeResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["UserEdge"] = ResolversParentTypes["UserEdge"]
> = ResolversObject<{
  cursor?: Resolver<ResolversTypes["Cursor"], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Resolvers<ContextType = any> = ResolversObject<{
  AggregateMetadata?: AggregateMetadataResolvers<ContextType>;
  Cursor?: GraphQLScalarType;
  EnumMetadata?: EnumMetadataResolvers<ContextType>;
  EnumMetric?: EnumMetricResolvers<ContextType>;
  EnumOccurences?: EnumOccurencesResolvers<ContextType>;
  Favorites?: FavoritesResolvers<ContextType>;
  Game?: GameResolvers<ContextType>;
  GameConnection?: GameConnectionResolvers<ContextType>;
  GameEdge?: GameEdgeResolvers<ContextType>;
  GameVersion?: GameVersionResolvers<ContextType>;
  GameVersionMetrics?: GameVersionMetricsResolvers<ContextType>;
  Group?: GroupResolvers<ContextType>;
  GroupConnection?: GroupConnectionResolvers<ContextType>;
  GroupEdge?: GroupEdgeResolvers<ContextType>;
  GroupMembership?: GroupMembershipResolvers<ContextType>;
  GroupMembershipApplication?: GroupMembershipApplicationResolvers<ContextType>;
  GroupMembershipConnection?: GroupMembershipConnectionResolvers<ContextType>;
  GroupMembershipEdge?: GroupMembershipEdgeResolvers<ContextType>;
  GroupSettings?: GroupSettingsResolvers<ContextType>;
  Header?: HeaderResolvers<ContextType>;
  Match?: MatchResolvers<ContextType>;
  MatchConnection?: MatchConnectionResolvers<ContextType>;
  MatchEdge?: MatchEdgeResolvers<ContextType>;
  Mutation?: MutationResolvers<ContextType>;
  Node?: NodeResolvers<ContextType>;
  NumericMetric?: NumericMetricResolvers<ContextType>;
  PageInfo?: PageInfoResolvers<ContextType>;
  Player?: PlayerResolvers<ContextType>;
  PlayerConnection?: PlayerConnectionResolvers<ContextType>;
  PlayerEdge?: PlayerEdgeResolvers<ContextType>;
  PlayerSupervisionRequest?: PlayerSupervisionRequestResolvers<ContextType>;
  PlayerSupervisionRequestApproval?: PlayerSupervisionRequestApprovalResolvers<ContextType>;
  Query?: QueryResolvers<ContextType>;
  StatDescription?: StatDescriptionResolvers<ContextType>;
  Statistic?: StatisticResolvers<ContextType>;
  Time?: GraphQLScalarType;
  TimeFloatMetric?: TimeFloatMetricResolvers<ContextType>;
  TimeSeries?: TimeSeriesResolvers<ContextType>;
  TimeSeriesPeriod?: TimeSeriesPeriodResolvers<ContextType>;
  UploadURL?: UploadUrlResolvers<ContextType>;
  User?: UserResolvers<ContextType>;
  UserConnection?: UserConnectionResolvers<ContextType>;
  UserEdge?: UserEdgeResolvers<ContextType>;
}>;

export type DirectiveResolvers<ContextType = any> = ResolversObject<{
  authenticated?: AuthenticatedDirectiveResolver<any, any, ContextType>;
  defer?: DeferDirectiveResolver<any, any, ContextType>;
  goField?: GoFieldDirectiveResolver<any, any, ContextType>;
  goModel?: GoModelDirectiveResolver<any, any, ContextType>;
}>;
