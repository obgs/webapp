import { gql } from "@apollo/client";
import * as Apollo from "@apollo/client";
import {
  GraphQLResolveInfo,
  GraphQLScalarType,
  GraphQLScalarTypeConfig,
} from "graphql";
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = {
  [K in keyof T]: T[K];
};
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]?: Maybe<T[SubKey]>;
};
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]: Maybe<T[SubKey]>;
};
export type RequireFields<T, K extends keyof T> = Omit<T, K> & {
  [P in K]-?: NonNullable<T[P]>;
};
const defaultOptions = {} as const;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  Cursor: any;
};

export type CreatePlayerInput = {
  name: Scalars["String"];
};

export type Mutation = {
  __typename?: "Mutation";
  createPlayer: Player;
  requestPlayerSupervision: PlayerSupervisionRequest;
  resolvePlayerSupervisionRequest: Scalars["Boolean"];
  updateUser: User;
};

export type MutationCreatePlayerArgs = {
  input: CreatePlayerInput;
};

export type MutationRequestPlayerSupervisionArgs = {
  input?: InputMaybe<RequestPlayerSupervisionInput>;
};

export type MutationResolvePlayerSupervisionRequestArgs = {
  input: ResolvePlayerSupervisionRequestInput;
};

export type MutationUpdateUserArgs = {
  id: Scalars["ID"];
  input: UpdateUserInput;
};

/**
 * An object with an ID.
 * Follows the [Relay Global Object Identification Specification](https://relay.dev/graphql/objectidentification.htm)
 */
export type Node = {
  /** The id of the object. */
  id: Scalars["ID"];
};

/** Possible directions in which to order a list of items when provided an `orderBy` argument. */
export enum OrderDirection {
  /** Specifies an ascending order for a given `orderBy` argument. */
  Asc = "ASC",
  /** Specifies a descending order for a given `orderBy` argument. */
  Desc = "DESC",
}

/**
 * Information about pagination in a connection.
 * https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo
 */
export type PageInfo = {
  __typename?: "PageInfo";
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars["Cursor"]>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars["Boolean"];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars["Boolean"];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars["Cursor"]>;
};

export type Player = Node & {
  __typename?: "Player";
  id: Scalars["ID"];
  name: Scalars["String"];
  owner?: Maybe<User>;
  supervisionRequests?: Maybe<Array<PlayerSupervisionRequest>>;
  supervisors?: Maybe<Array<User>>;
};

/** A connection to a list of items. */
export type PlayerConnection = {
  __typename?: "PlayerConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PlayerEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"];
};

/** An edge in a connection. */
export type PlayerEdge = {
  __typename?: "PlayerEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["Cursor"];
  /** The item at the end of the edge. */
  node?: Maybe<Player>;
};

export type PlayerSupervisionRequest = Node & {
  __typename?: "PlayerSupervisionRequest";
  approvals?: Maybe<Array<PlayerSupervisionRequestApproval>>;
  id: Scalars["ID"];
  message?: Maybe<Scalars["String"]>;
  player: Player;
  sender: User;
};

export type PlayerSupervisionRequestApproval = Node & {
  __typename?: "PlayerSupervisionRequestApproval";
  approved?: Maybe<Scalars["Boolean"]>;
  approver: User;
  id: Scalars["ID"];
  supervisionRequest: PlayerSupervisionRequest;
};

/**
 * PlayerSupervisionRequestApprovalWhereInput is used for filtering PlayerSupervisionRequestApproval objects.
 * Input was generated by ent.
 */
export type PlayerSupervisionRequestApprovalWhereInput = {
  and?: InputMaybe<Array<PlayerSupervisionRequestApprovalWhereInput>>;
  /** approved field predicates */
  approved?: InputMaybe<Scalars["Boolean"]>;
  approvedIsNil?: InputMaybe<Scalars["Boolean"]>;
  approvedNEQ?: InputMaybe<Scalars["Boolean"]>;
  approvedNotNil?: InputMaybe<Scalars["Boolean"]>;
  /** approver edge predicates */
  hasApprover?: InputMaybe<Scalars["Boolean"]>;
  hasApproverWith?: InputMaybe<Array<UserWhereInput>>;
  /** supervision_request edge predicates */
  hasSupervisionRequest?: InputMaybe<Scalars["Boolean"]>;
  hasSupervisionRequestWith?: InputMaybe<
    Array<PlayerSupervisionRequestWhereInput>
  >;
  /** id field predicates */
  id?: InputMaybe<Scalars["ID"]>;
  idGT?: InputMaybe<Scalars["ID"]>;
  idGTE?: InputMaybe<Scalars["ID"]>;
  idIn?: InputMaybe<Array<Scalars["ID"]>>;
  idLT?: InputMaybe<Scalars["ID"]>;
  idLTE?: InputMaybe<Scalars["ID"]>;
  idNEQ?: InputMaybe<Scalars["ID"]>;
  idNotIn?: InputMaybe<Array<Scalars["ID"]>>;
  not?: InputMaybe<PlayerSupervisionRequestApprovalWhereInput>;
  or?: InputMaybe<Array<PlayerSupervisionRequestApprovalWhereInput>>;
};

/**
 * PlayerSupervisionRequestWhereInput is used for filtering PlayerSupervisionRequest objects.
 * Input was generated by ent.
 */
export type PlayerSupervisionRequestWhereInput = {
  and?: InputMaybe<Array<PlayerSupervisionRequestWhereInput>>;
  /** approvals edge predicates */
  hasApprovals?: InputMaybe<Scalars["Boolean"]>;
  hasApprovalsWith?: InputMaybe<
    Array<PlayerSupervisionRequestApprovalWhereInput>
  >;
  /** player edge predicates */
  hasPlayer?: InputMaybe<Scalars["Boolean"]>;
  hasPlayerWith?: InputMaybe<Array<PlayerWhereInput>>;
  /** sender edge predicates */
  hasSender?: InputMaybe<Scalars["Boolean"]>;
  hasSenderWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars["ID"]>;
  idGT?: InputMaybe<Scalars["ID"]>;
  idGTE?: InputMaybe<Scalars["ID"]>;
  idIn?: InputMaybe<Array<Scalars["ID"]>>;
  idLT?: InputMaybe<Scalars["ID"]>;
  idLTE?: InputMaybe<Scalars["ID"]>;
  idNEQ?: InputMaybe<Scalars["ID"]>;
  idNotIn?: InputMaybe<Array<Scalars["ID"]>>;
  not?: InputMaybe<PlayerSupervisionRequestWhereInput>;
  or?: InputMaybe<Array<PlayerSupervisionRequestWhereInput>>;
};

/**
 * PlayerWhereInput is used for filtering Player objects.
 * Input was generated by ent.
 */
export type PlayerWhereInput = {
  and?: InputMaybe<Array<PlayerWhereInput>>;
  /** owner edge predicates */
  hasOwner?: InputMaybe<Scalars["Boolean"]>;
  hasOwnerWith?: InputMaybe<Array<UserWhereInput>>;
  /** supervision_requests edge predicates */
  hasSupervisionRequests?: InputMaybe<Scalars["Boolean"]>;
  hasSupervisionRequestsWith?: InputMaybe<
    Array<PlayerSupervisionRequestWhereInput>
  >;
  /** supervisors edge predicates */
  hasSupervisors?: InputMaybe<Scalars["Boolean"]>;
  hasSupervisorsWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars["ID"]>;
  idGT?: InputMaybe<Scalars["ID"]>;
  idGTE?: InputMaybe<Scalars["ID"]>;
  idIn?: InputMaybe<Array<Scalars["ID"]>>;
  idLT?: InputMaybe<Scalars["ID"]>;
  idLTE?: InputMaybe<Scalars["ID"]>;
  idNEQ?: InputMaybe<Scalars["ID"]>;
  idNotIn?: InputMaybe<Array<Scalars["ID"]>>;
  /** name field predicates */
  name?: InputMaybe<Scalars["String"]>;
  nameContains?: InputMaybe<Scalars["String"]>;
  nameContainsFold?: InputMaybe<Scalars["String"]>;
  nameEqualFold?: InputMaybe<Scalars["String"]>;
  nameGT?: InputMaybe<Scalars["String"]>;
  nameGTE?: InputMaybe<Scalars["String"]>;
  nameHasPrefix?: InputMaybe<Scalars["String"]>;
  nameHasSuffix?: InputMaybe<Scalars["String"]>;
  nameIn?: InputMaybe<Array<Scalars["String"]>>;
  nameLT?: InputMaybe<Scalars["String"]>;
  nameLTE?: InputMaybe<Scalars["String"]>;
  nameNEQ?: InputMaybe<Scalars["String"]>;
  nameNotIn?: InputMaybe<Array<Scalars["String"]>>;
  not?: InputMaybe<PlayerWhereInput>;
  or?: InputMaybe<Array<PlayerWhereInput>>;
};

export type Query = {
  __typename?: "Query";
  getFileUploadURL: Scalars["String"];
  me: User;
  /** Fetches an object given its ID. */
  node?: Maybe<Node>;
  /** Lookup nodes by a list of IDs. */
  nodes: Array<Maybe<Node>>;
  players: PlayerConnection;
  users: UserConnection;
};

export type QueryNodeArgs = {
  id: Scalars["ID"];
};

export type QueryNodesArgs = {
  ids: Array<Scalars["ID"]>;
};

export type QueryPlayersArgs = {
  after?: InputMaybe<Scalars["Cursor"]>;
  before?: InputMaybe<Scalars["Cursor"]>;
  first?: InputMaybe<Scalars["Int"]>;
  last?: InputMaybe<Scalars["Int"]>;
  where?: InputMaybe<PlayerWhereInput>;
};

export type QueryUsersArgs = {
  after?: InputMaybe<Scalars["Cursor"]>;
  before?: InputMaybe<Scalars["Cursor"]>;
  first?: InputMaybe<Scalars["Int"]>;
  last?: InputMaybe<Scalars["Int"]>;
  where?: InputMaybe<UserWhereInput>;
};

export type RequestPlayerSupervisionInput = {
  message?: InputMaybe<Scalars["String"]>;
  playerId: Scalars["ID"];
};

export type ResolvePlayerSupervisionRequestInput = {
  approved: Scalars["Boolean"];
  requestId: Scalars["ID"];
};

/**
 * UpdateUserInput is used for update User object.
 * Input was generated by ent.
 */
export type UpdateUserInput = {
  addPlayerIDs?: InputMaybe<Array<Scalars["ID"]>>;
  avatarURL?: InputMaybe<Scalars["String"]>;
  clearMainPlayer?: InputMaybe<Scalars["Boolean"]>;
  email?: InputMaybe<Scalars["String"]>;
  mainPlayerID?: InputMaybe<Scalars["ID"]>;
  name?: InputMaybe<Scalars["String"]>;
  removePlayerIDs?: InputMaybe<Array<Scalars["ID"]>>;
};

export type User = Node & {
  __typename?: "User";
  avatarURL: Scalars["String"];
  email: Scalars["String"];
  id: Scalars["ID"];
  mainPlayer?: Maybe<Player>;
  name: Scalars["String"];
  players?: Maybe<Array<Player>>;
  receivedSupervisionRequests: Array<PlayerSupervisionRequest>;
  sentSupervisionRequests: Array<PlayerSupervisionRequest>;
};

/** A connection to a list of items. */
export type UserConnection = {
  __typename?: "UserConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<UserEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"];
};

/** An edge in a connection. */
export type UserEdge = {
  __typename?: "UserEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["Cursor"];
  /** The item at the end of the edge. */
  node?: Maybe<User>;
};

/**
 * UserWhereInput is used for filtering User objects.
 * Input was generated by ent.
 */
export type UserWhereInput = {
  and?: InputMaybe<Array<UserWhereInput>>;
  /** email field predicates */
  email?: InputMaybe<Scalars["String"]>;
  emailContains?: InputMaybe<Scalars["String"]>;
  emailContainsFold?: InputMaybe<Scalars["String"]>;
  emailEqualFold?: InputMaybe<Scalars["String"]>;
  emailGT?: InputMaybe<Scalars["String"]>;
  emailGTE?: InputMaybe<Scalars["String"]>;
  emailHasPrefix?: InputMaybe<Scalars["String"]>;
  emailHasSuffix?: InputMaybe<Scalars["String"]>;
  emailIn?: InputMaybe<Array<Scalars["String"]>>;
  emailLT?: InputMaybe<Scalars["String"]>;
  emailLTE?: InputMaybe<Scalars["String"]>;
  emailNEQ?: InputMaybe<Scalars["String"]>;
  emailNotIn?: InputMaybe<Array<Scalars["String"]>>;
  /** main_player edge predicates */
  hasMainPlayer?: InputMaybe<Scalars["Boolean"]>;
  hasMainPlayerWith?: InputMaybe<Array<PlayerWhereInput>>;
  /** players edge predicates */
  hasPlayers?: InputMaybe<Scalars["Boolean"]>;
  hasPlayersWith?: InputMaybe<Array<PlayerWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars["ID"]>;
  idGT?: InputMaybe<Scalars["ID"]>;
  idGTE?: InputMaybe<Scalars["ID"]>;
  idIn?: InputMaybe<Array<Scalars["ID"]>>;
  idLT?: InputMaybe<Scalars["ID"]>;
  idLTE?: InputMaybe<Scalars["ID"]>;
  idNEQ?: InputMaybe<Scalars["ID"]>;
  idNotIn?: InputMaybe<Array<Scalars["ID"]>>;
  /** name field predicates */
  name?: InputMaybe<Scalars["String"]>;
  nameContains?: InputMaybe<Scalars["String"]>;
  nameContainsFold?: InputMaybe<Scalars["String"]>;
  nameEqualFold?: InputMaybe<Scalars["String"]>;
  nameGT?: InputMaybe<Scalars["String"]>;
  nameGTE?: InputMaybe<Scalars["String"]>;
  nameHasPrefix?: InputMaybe<Scalars["String"]>;
  nameHasSuffix?: InputMaybe<Scalars["String"]>;
  nameIn?: InputMaybe<Array<Scalars["String"]>>;
  nameLT?: InputMaybe<Scalars["String"]>;
  nameLTE?: InputMaybe<Scalars["String"]>;
  nameNEQ?: InputMaybe<Scalars["String"]>;
  nameNotIn?: InputMaybe<Array<Scalars["String"]>>;
  not?: InputMaybe<UserWhereInput>;
  or?: InputMaybe<Array<UserWhereInput>>;
};

export type PageInfoFieldsFragment = {
  __typename?: "PageInfo";
  hasNextPage: boolean;
  hasPreviousPage: boolean;
  startCursor?: any | null;
  endCursor?: any | null;
};

export type PlayerFieldsFragment = {
  __typename?: "Player";
  id: string;
  name: string;
  owner?: { __typename?: "User"; id: string; name: string } | null;
  supervisors?: Array<{ __typename?: "User"; id: string; name: string }> | null;
};

export type PlayerSupervisionRequestFieldsFragment = {
  __typename?: "PlayerSupervisionRequest";
  id: string;
  message?: string | null;
  sender: { __typename?: "User"; id: string; name: string; avatarURL: string };
  player: {
    __typename?: "Player";
    id: string;
    name: string;
    owner?: { __typename?: "User"; id: string; name: string } | null;
    supervisors?: Array<{
      __typename?: "User";
      id: string;
      name: string;
    }> | null;
  };
  approvals?: Array<{
    __typename?: "PlayerSupervisionRequestApproval";
    approved?: boolean | null;
    approver: {
      __typename?: "User";
      id: string;
      name: string;
      avatarURL: string;
    };
  }> | null;
};

export type CreatePlayerMutationVariables = Exact<{
  name: Scalars["String"];
}>;

export type CreatePlayerMutation = {
  __typename?: "Mutation";
  createPlayer: { __typename?: "Player"; id: string; name: string };
};

export type RequestPlayerSupervisionMutationVariables = Exact<{
  input: RequestPlayerSupervisionInput;
}>;

export type RequestPlayerSupervisionMutation = {
  __typename?: "Mutation";
  requestPlayerSupervision: {
    __typename?: "PlayerSupervisionRequest";
    id: string;
  };
};

export type ResolvePlayerSupervisionRequestMutationVariables = Exact<{
  input: ResolvePlayerSupervisionRequestInput;
}>;

export type ResolvePlayerSupervisionRequestMutation = {
  __typename?: "Mutation";
  resolvePlayerSupervisionRequest: boolean;
};

export type UpdateUserMutationVariables = Exact<{
  id: Scalars["ID"];
  input: UpdateUserInput;
}>;

export type UpdateUserMutation = {
  __typename?: "Mutation";
  updateUser: { __typename?: "User"; id: string };
};

export type GetFileUploadUrlQueryVariables = Exact<{ [key: string]: never }>;

export type GetFileUploadUrlQuery = {
  __typename?: "Query";
  getFileUploadURL: string;
};

export type IncomingSupervisionRequestsQueryVariables = Exact<{
  [key: string]: never;
}>;

export type IncomingSupervisionRequestsQuery = {
  __typename?: "Query";
  me: {
    __typename?: "User";
    receivedSupervisionRequests: Array<{
      __typename?: "PlayerSupervisionRequest";
      id: string;
      message?: string | null;
      sender: {
        __typename?: "User";
        id: string;
        name: string;
        avatarURL: string;
      };
      player: {
        __typename?: "Player";
        id: string;
        name: string;
        owner?: { __typename?: "User"; id: string; name: string } | null;
        supervisors?: Array<{
          __typename?: "User";
          id: string;
          name: string;
        }> | null;
      };
      approvals?: Array<{
        __typename?: "PlayerSupervisionRequestApproval";
        approved?: boolean | null;
        approver: {
          __typename?: "User";
          id: string;
          name: string;
          avatarURL: string;
        };
      }> | null;
    }>;
  };
};

export type MeQueryVariables = Exact<{ [key: string]: never }>;

export type MeQuery = {
  __typename?: "Query";
  me: {
    __typename?: "User";
    id: string;
    name: string;
    email: string;
    avatarURL: string;
  };
};

export type MyPlayersQueryVariables = Exact<{ [key: string]: never }>;

export type MyPlayersQuery = {
  __typename?: "Query";
  me: {
    __typename?: "User";
    players?: Array<{
      __typename?: "Player";
      id: string;
      name: string;
      owner?: { __typename?: "User"; id: string; name: string } | null;
      supervisors?: Array<{
        __typename?: "User";
        id: string;
        name: string;
      }> | null;
    }> | null;
  };
};

export type PendingSupervisionRequestsQueryVariables = Exact<{
  [key: string]: never;
}>;

export type PendingSupervisionRequestsQuery = {
  __typename?: "Query";
  me: {
    __typename?: "User";
    sentSupervisionRequests: Array<{
      __typename?: "PlayerSupervisionRequest";
      id: string;
      message?: string | null;
      sender: {
        __typename?: "User";
        id: string;
        name: string;
        avatarURL: string;
      };
      player: {
        __typename?: "Player";
        id: string;
        name: string;
        owner?: { __typename?: "User"; id: string; name: string } | null;
        supervisors?: Array<{
          __typename?: "User";
          id: string;
          name: string;
        }> | null;
      };
      approvals?: Array<{
        __typename?: "PlayerSupervisionRequestApproval";
        approved?: boolean | null;
        approver: {
          __typename?: "User";
          id: string;
          name: string;
          avatarURL: string;
        };
      }> | null;
    }>;
  };
};

export type SearchPlayersQueryVariables = Exact<{
  before?: InputMaybe<Scalars["Cursor"]>;
  after?: InputMaybe<Scalars["Cursor"]>;
  where: PlayerWhereInput;
  first?: InputMaybe<Scalars["Int"]>;
  last?: InputMaybe<Scalars["Int"]>;
}>;

export type SearchPlayersQuery = {
  __typename?: "Query";
  players: {
    __typename?: "PlayerConnection";
    totalCount: number;
    pageInfo: {
      __typename?: "PageInfo";
      hasNextPage: boolean;
      hasPreviousPage: boolean;
      startCursor?: any | null;
      endCursor?: any | null;
    };
    edges?: Array<{
      __typename?: "PlayerEdge";
      cursor: any;
      node?: {
        __typename?: "Player";
        id: string;
        name: string;
        owner?: { __typename?: "User"; id: string; name: string } | null;
        supervisors?: Array<{
          __typename?: "User";
          id: string;
          name: string;
        }> | null;
      } | null;
    } | null> | null;
  };
};

export const PageInfoFieldsFragmentDoc = gql`
  fragment pageInfoFields on PageInfo {
    hasNextPage
    hasPreviousPage
    startCursor
    endCursor
  }
`;
export const PlayerFieldsFragmentDoc = gql`
  fragment playerFields on Player {
    id
    name
    owner {
      id
      name
    }
    supervisors {
      id
      name
    }
  }
`;
export const PlayerSupervisionRequestFieldsFragmentDoc = gql`
  fragment playerSupervisionRequestFields on PlayerSupervisionRequest {
    id
    message
    sender {
      id
      name
      avatarURL
    }
    player {
      ...playerFields
    }
    approvals {
      approved
      approver {
        id
        name
        avatarURL
      }
    }
  }
  ${PlayerFieldsFragmentDoc}
`;
export const CreatePlayerDocument = gql`
  mutation CreatePlayer($name: String!) {
    createPlayer(input: { name: $name }) {
      id
      name
    }
  }
`;
export type CreatePlayerMutationFn = Apollo.MutationFunction<
  CreatePlayerMutation,
  CreatePlayerMutationVariables
>;

/**
 * __useCreatePlayerMutation__
 *
 * To run a mutation, you first call `useCreatePlayerMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreatePlayerMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createPlayerMutation, { data, loading, error }] = useCreatePlayerMutation({
 *   variables: {
 *      name: // value for 'name'
 *   },
 * });
 */
export function useCreatePlayerMutation(
  baseOptions?: Apollo.MutationHookOptions<
    CreatePlayerMutation,
    CreatePlayerMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useMutation<
    CreatePlayerMutation,
    CreatePlayerMutationVariables
  >(CreatePlayerDocument, options);
}
export type CreatePlayerMutationHookResult = ReturnType<
  typeof useCreatePlayerMutation
>;
export type CreatePlayerMutationResult =
  Apollo.MutationResult<CreatePlayerMutation>;
export type CreatePlayerMutationOptions = Apollo.BaseMutationOptions<
  CreatePlayerMutation,
  CreatePlayerMutationVariables
>;
export const RequestPlayerSupervisionDocument = gql`
  mutation RequestPlayerSupervision($input: RequestPlayerSupervisionInput!) {
    requestPlayerSupervision(input: $input) {
      id
    }
  }
`;
export type RequestPlayerSupervisionMutationFn = Apollo.MutationFunction<
  RequestPlayerSupervisionMutation,
  RequestPlayerSupervisionMutationVariables
>;

/**
 * __useRequestPlayerSupervisionMutation__
 *
 * To run a mutation, you first call `useRequestPlayerSupervisionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRequestPlayerSupervisionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [requestPlayerSupervisionMutation, { data, loading, error }] = useRequestPlayerSupervisionMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useRequestPlayerSupervisionMutation(
  baseOptions?: Apollo.MutationHookOptions<
    RequestPlayerSupervisionMutation,
    RequestPlayerSupervisionMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useMutation<
    RequestPlayerSupervisionMutation,
    RequestPlayerSupervisionMutationVariables
  >(RequestPlayerSupervisionDocument, options);
}
export type RequestPlayerSupervisionMutationHookResult = ReturnType<
  typeof useRequestPlayerSupervisionMutation
>;
export type RequestPlayerSupervisionMutationResult =
  Apollo.MutationResult<RequestPlayerSupervisionMutation>;
export type RequestPlayerSupervisionMutationOptions =
  Apollo.BaseMutationOptions<
    RequestPlayerSupervisionMutation,
    RequestPlayerSupervisionMutationVariables
  >;
export const ResolvePlayerSupervisionRequestDocument = gql`
  mutation ResolvePlayerSupervisionRequest(
    $input: ResolvePlayerSupervisionRequestInput!
  ) {
    resolvePlayerSupervisionRequest(input: $input)
  }
`;
export type ResolvePlayerSupervisionRequestMutationFn = Apollo.MutationFunction<
  ResolvePlayerSupervisionRequestMutation,
  ResolvePlayerSupervisionRequestMutationVariables
>;

/**
 * __useResolvePlayerSupervisionRequestMutation__
 *
 * To run a mutation, you first call `useResolvePlayerSupervisionRequestMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useResolvePlayerSupervisionRequestMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [resolvePlayerSupervisionRequestMutation, { data, loading, error }] = useResolvePlayerSupervisionRequestMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useResolvePlayerSupervisionRequestMutation(
  baseOptions?: Apollo.MutationHookOptions<
    ResolvePlayerSupervisionRequestMutation,
    ResolvePlayerSupervisionRequestMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useMutation<
    ResolvePlayerSupervisionRequestMutation,
    ResolvePlayerSupervisionRequestMutationVariables
  >(ResolvePlayerSupervisionRequestDocument, options);
}
export type ResolvePlayerSupervisionRequestMutationHookResult = ReturnType<
  typeof useResolvePlayerSupervisionRequestMutation
>;
export type ResolvePlayerSupervisionRequestMutationResult =
  Apollo.MutationResult<ResolvePlayerSupervisionRequestMutation>;
export type ResolvePlayerSupervisionRequestMutationOptions =
  Apollo.BaseMutationOptions<
    ResolvePlayerSupervisionRequestMutation,
    ResolvePlayerSupervisionRequestMutationVariables
  >;
export const UpdateUserDocument = gql`
  mutation UpdateUser($id: ID!, $input: UpdateUserInput!) {
    updateUser(id: $id, input: $input) {
      id
    }
  }
`;
export type UpdateUserMutationFn = Apollo.MutationFunction<
  UpdateUserMutation,
  UpdateUserMutationVariables
>;

/**
 * __useUpdateUserMutation__
 *
 * To run a mutation, you first call `useUpdateUserMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateUserMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateUserMutation, { data, loading, error }] = useUpdateUserMutation({
 *   variables: {
 *      id: // value for 'id'
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateUserMutation(
  baseOptions?: Apollo.MutationHookOptions<
    UpdateUserMutation,
    UpdateUserMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useMutation<UpdateUserMutation, UpdateUserMutationVariables>(
    UpdateUserDocument,
    options
  );
}
export type UpdateUserMutationHookResult = ReturnType<
  typeof useUpdateUserMutation
>;
export type UpdateUserMutationResult =
  Apollo.MutationResult<UpdateUserMutation>;
export type UpdateUserMutationOptions = Apollo.BaseMutationOptions<
  UpdateUserMutation,
  UpdateUserMutationVariables
>;
export const GetFileUploadUrlDocument = gql`
  query GetFileUploadURL {
    getFileUploadURL
  }
`;

/**
 * __useGetFileUploadUrlQuery__
 *
 * To run a query within a React component, call `useGetFileUploadUrlQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetFileUploadUrlQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetFileUploadUrlQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetFileUploadUrlQuery(
  baseOptions?: Apollo.QueryHookOptions<
    GetFileUploadUrlQuery,
    GetFileUploadUrlQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<GetFileUploadUrlQuery, GetFileUploadUrlQueryVariables>(
    GetFileUploadUrlDocument,
    options
  );
}
export function useGetFileUploadUrlLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetFileUploadUrlQuery,
    GetFileUploadUrlQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<
    GetFileUploadUrlQuery,
    GetFileUploadUrlQueryVariables
  >(GetFileUploadUrlDocument, options);
}
export type GetFileUploadUrlQueryHookResult = ReturnType<
  typeof useGetFileUploadUrlQuery
>;
export type GetFileUploadUrlLazyQueryHookResult = ReturnType<
  typeof useGetFileUploadUrlLazyQuery
>;
export type GetFileUploadUrlQueryResult = Apollo.QueryResult<
  GetFileUploadUrlQuery,
  GetFileUploadUrlQueryVariables
>;
export const IncomingSupervisionRequestsDocument = gql`
  query IncomingSupervisionRequests {
    me {
      receivedSupervisionRequests {
        ...playerSupervisionRequestFields
      }
    }
  }
  ${PlayerSupervisionRequestFieldsFragmentDoc}
`;

/**
 * __useIncomingSupervisionRequestsQuery__
 *
 * To run a query within a React component, call `useIncomingSupervisionRequestsQuery` and pass it any options that fit your needs.
 * When your component renders, `useIncomingSupervisionRequestsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useIncomingSupervisionRequestsQuery({
 *   variables: {
 *   },
 * });
 */
export function useIncomingSupervisionRequestsQuery(
  baseOptions?: Apollo.QueryHookOptions<
    IncomingSupervisionRequestsQuery,
    IncomingSupervisionRequestsQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<
    IncomingSupervisionRequestsQuery,
    IncomingSupervisionRequestsQueryVariables
  >(IncomingSupervisionRequestsDocument, options);
}
export function useIncomingSupervisionRequestsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    IncomingSupervisionRequestsQuery,
    IncomingSupervisionRequestsQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<
    IncomingSupervisionRequestsQuery,
    IncomingSupervisionRequestsQueryVariables
  >(IncomingSupervisionRequestsDocument, options);
}
export type IncomingSupervisionRequestsQueryHookResult = ReturnType<
  typeof useIncomingSupervisionRequestsQuery
>;
export type IncomingSupervisionRequestsLazyQueryHookResult = ReturnType<
  typeof useIncomingSupervisionRequestsLazyQuery
>;
export type IncomingSupervisionRequestsQueryResult = Apollo.QueryResult<
  IncomingSupervisionRequestsQuery,
  IncomingSupervisionRequestsQueryVariables
>;
export const MeDocument = gql`
  query Me {
    me {
      id
      name
      email
      avatarURL
    }
  }
`;

/**
 * __useMeQuery__
 *
 * To run a query within a React component, call `useMeQuery` and pass it any options that fit your needs.
 * When your component renders, `useMeQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMeQuery({
 *   variables: {
 *   },
 * });
 */
export function useMeQuery(
  baseOptions?: Apollo.QueryHookOptions<MeQuery, MeQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<MeQuery, MeQueryVariables>(MeDocument, options);
}
export function useMeLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<MeQuery, MeQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<MeQuery, MeQueryVariables>(MeDocument, options);
}
export type MeQueryHookResult = ReturnType<typeof useMeQuery>;
export type MeLazyQueryHookResult = ReturnType<typeof useMeLazyQuery>;
export type MeQueryResult = Apollo.QueryResult<MeQuery, MeQueryVariables>;
export const MyPlayersDocument = gql`
  query MyPlayers {
    me {
      players {
        ...playerFields
      }
    }
  }
  ${PlayerFieldsFragmentDoc}
`;

/**
 * __useMyPlayersQuery__
 *
 * To run a query within a React component, call `useMyPlayersQuery` and pass it any options that fit your needs.
 * When your component renders, `useMyPlayersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMyPlayersQuery({
 *   variables: {
 *   },
 * });
 */
export function useMyPlayersQuery(
  baseOptions?: Apollo.QueryHookOptions<MyPlayersQuery, MyPlayersQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<MyPlayersQuery, MyPlayersQueryVariables>(
    MyPlayersDocument,
    options
  );
}
export function useMyPlayersLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    MyPlayersQuery,
    MyPlayersQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<MyPlayersQuery, MyPlayersQueryVariables>(
    MyPlayersDocument,
    options
  );
}
export type MyPlayersQueryHookResult = ReturnType<typeof useMyPlayersQuery>;
export type MyPlayersLazyQueryHookResult = ReturnType<
  typeof useMyPlayersLazyQuery
>;
export type MyPlayersQueryResult = Apollo.QueryResult<
  MyPlayersQuery,
  MyPlayersQueryVariables
>;
export const PendingSupervisionRequestsDocument = gql`
  query PendingSupervisionRequests {
    me {
      sentSupervisionRequests {
        ...playerSupervisionRequestFields
      }
    }
  }
  ${PlayerSupervisionRequestFieldsFragmentDoc}
`;

/**
 * __usePendingSupervisionRequestsQuery__
 *
 * To run a query within a React component, call `usePendingSupervisionRequestsQuery` and pass it any options that fit your needs.
 * When your component renders, `usePendingSupervisionRequestsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePendingSupervisionRequestsQuery({
 *   variables: {
 *   },
 * });
 */
export function usePendingSupervisionRequestsQuery(
  baseOptions?: Apollo.QueryHookOptions<
    PendingSupervisionRequestsQuery,
    PendingSupervisionRequestsQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<
    PendingSupervisionRequestsQuery,
    PendingSupervisionRequestsQueryVariables
  >(PendingSupervisionRequestsDocument, options);
}
export function usePendingSupervisionRequestsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    PendingSupervisionRequestsQuery,
    PendingSupervisionRequestsQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<
    PendingSupervisionRequestsQuery,
    PendingSupervisionRequestsQueryVariables
  >(PendingSupervisionRequestsDocument, options);
}
export type PendingSupervisionRequestsQueryHookResult = ReturnType<
  typeof usePendingSupervisionRequestsQuery
>;
export type PendingSupervisionRequestsLazyQueryHookResult = ReturnType<
  typeof usePendingSupervisionRequestsLazyQuery
>;
export type PendingSupervisionRequestsQueryResult = Apollo.QueryResult<
  PendingSupervisionRequestsQuery,
  PendingSupervisionRequestsQueryVariables
>;
export const SearchPlayersDocument = gql`
  query SearchPlayers(
    $before: Cursor
    $after: Cursor
    $where: PlayerWhereInput!
    $first: Int
    $last: Int
  ) {
    players(
      before: $before
      after: $after
      where: $where
      first: $first
      last: $last
    ) {
      pageInfo {
        ...pageInfoFields
      }
      totalCount
      edges {
        cursor
        node {
          ...playerFields
        }
      }
    }
  }
  ${PageInfoFieldsFragmentDoc}
  ${PlayerFieldsFragmentDoc}
`;

/**
 * __useSearchPlayersQuery__
 *
 * To run a query within a React component, call `useSearchPlayersQuery` and pass it any options that fit your needs.
 * When your component renders, `useSearchPlayersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSearchPlayersQuery({
 *   variables: {
 *      before: // value for 'before'
 *      after: // value for 'after'
 *      where: // value for 'where'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useSearchPlayersQuery(
  baseOptions: Apollo.QueryHookOptions<
    SearchPlayersQuery,
    SearchPlayersQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<SearchPlayersQuery, SearchPlayersQueryVariables>(
    SearchPlayersDocument,
    options
  );
}
export function useSearchPlayersLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    SearchPlayersQuery,
    SearchPlayersQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<SearchPlayersQuery, SearchPlayersQueryVariables>(
    SearchPlayersDocument,
    options
  );
}
export type SearchPlayersQueryHookResult = ReturnType<
  typeof useSearchPlayersQuery
>;
export type SearchPlayersLazyQueryHookResult = ReturnType<
  typeof useSearchPlayersLazyQuery
>;
export type SearchPlayersQueryResult = Apollo.QueryResult<
  SearchPlayersQuery,
  SearchPlayersQueryVariables
>;
export type WithIndex<TObject> = TObject & Record<string, any>;
export type ResolversObject<TObject> = WithIndex<TObject>;

export type ResolverTypeWrapper<T> = Promise<T> | T;

export type ResolverWithResolve<TResult, TParent, TContext, TArgs> = {
  resolve: ResolverFn<TResult, TParent, TContext, TArgs>;
};
export type Resolver<TResult, TParent = {}, TContext = {}, TArgs = {}> =
  | ResolverFn<TResult, TParent, TContext, TArgs>
  | ResolverWithResolve<TResult, TParent, TContext, TArgs>;

export type ResolverFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => Promise<TResult> | TResult;

export type SubscriptionSubscribeFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => AsyncIterable<TResult> | Promise<AsyncIterable<TResult>>;

export type SubscriptionResolveFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => TResult | Promise<TResult>;

export interface SubscriptionSubscriberObject<
  TResult,
  TKey extends string,
  TParent,
  TContext,
  TArgs
> {
  subscribe: SubscriptionSubscribeFn<
    { [key in TKey]: TResult },
    TParent,
    TContext,
    TArgs
  >;
  resolve?: SubscriptionResolveFn<
    TResult,
    { [key in TKey]: TResult },
    TContext,
    TArgs
  >;
}

export interface SubscriptionResolverObject<TResult, TParent, TContext, TArgs> {
  subscribe: SubscriptionSubscribeFn<any, TParent, TContext, TArgs>;
  resolve: SubscriptionResolveFn<TResult, any, TContext, TArgs>;
}

export type SubscriptionObject<
  TResult,
  TKey extends string,
  TParent,
  TContext,
  TArgs
> =
  | SubscriptionSubscriberObject<TResult, TKey, TParent, TContext, TArgs>
  | SubscriptionResolverObject<TResult, TParent, TContext, TArgs>;

export type SubscriptionResolver<
  TResult,
  TKey extends string,
  TParent = {},
  TContext = {},
  TArgs = {}
> =
  | ((
      ...args: any[]
    ) => SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>)
  | SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>;

export type TypeResolveFn<TTypes, TParent = {}, TContext = {}> = (
  parent: TParent,
  context: TContext,
  info: GraphQLResolveInfo
) => Maybe<TTypes> | Promise<Maybe<TTypes>>;

export type IsTypeOfResolverFn<T = {}, TContext = {}> = (
  obj: T,
  context: TContext,
  info: GraphQLResolveInfo
) => boolean | Promise<boolean>;

export type NextResolverFn<T> = () => Promise<T>;

export type DirectiveResolverFn<
  TResult = {},
  TParent = {},
  TContext = {},
  TArgs = {}
> = (
  next: NextResolverFn<TResult>,
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => TResult | Promise<TResult>;

/** Mapping between all available schema types and the resolvers types */
export type ResolversTypes = ResolversObject<{
  Boolean: ResolverTypeWrapper<Scalars["Boolean"]>;
  CreatePlayerInput: CreatePlayerInput;
  Cursor: ResolverTypeWrapper<Scalars["Cursor"]>;
  Float: ResolverTypeWrapper<Scalars["Float"]>;
  ID: ResolverTypeWrapper<Scalars["ID"]>;
  Int: ResolverTypeWrapper<Scalars["Int"]>;
  Mutation: ResolverTypeWrapper<{}>;
  Node:
    | ResolversTypes["Player"]
    | ResolversTypes["PlayerSupervisionRequest"]
    | ResolversTypes["PlayerSupervisionRequestApproval"]
    | ResolversTypes["User"];
  OrderDirection: OrderDirection;
  PageInfo: ResolverTypeWrapper<PageInfo>;
  Player: ResolverTypeWrapper<Player>;
  PlayerConnection: ResolverTypeWrapper<PlayerConnection>;
  PlayerEdge: ResolverTypeWrapper<PlayerEdge>;
  PlayerSupervisionRequest: ResolverTypeWrapper<PlayerSupervisionRequest>;
  PlayerSupervisionRequestApproval: ResolverTypeWrapper<PlayerSupervisionRequestApproval>;
  PlayerSupervisionRequestApprovalWhereInput: PlayerSupervisionRequestApprovalWhereInput;
  PlayerSupervisionRequestWhereInput: PlayerSupervisionRequestWhereInput;
  PlayerWhereInput: PlayerWhereInput;
  Query: ResolverTypeWrapper<{}>;
  RequestPlayerSupervisionInput: RequestPlayerSupervisionInput;
  ResolvePlayerSupervisionRequestInput: ResolvePlayerSupervisionRequestInput;
  String: ResolverTypeWrapper<Scalars["String"]>;
  UpdateUserInput: UpdateUserInput;
  User: ResolverTypeWrapper<User>;
  UserConnection: ResolverTypeWrapper<UserConnection>;
  UserEdge: ResolverTypeWrapper<UserEdge>;
  UserWhereInput: UserWhereInput;
}>;

/** Mapping between all available schema types and the resolvers parents */
export type ResolversParentTypes = ResolversObject<{
  Boolean: Scalars["Boolean"];
  CreatePlayerInput: CreatePlayerInput;
  Cursor: Scalars["Cursor"];
  Float: Scalars["Float"];
  ID: Scalars["ID"];
  Int: Scalars["Int"];
  Mutation: {};
  Node:
    | ResolversParentTypes["Player"]
    | ResolversParentTypes["PlayerSupervisionRequest"]
    | ResolversParentTypes["PlayerSupervisionRequestApproval"]
    | ResolversParentTypes["User"];
  PageInfo: PageInfo;
  Player: Player;
  PlayerConnection: PlayerConnection;
  PlayerEdge: PlayerEdge;
  PlayerSupervisionRequest: PlayerSupervisionRequest;
  PlayerSupervisionRequestApproval: PlayerSupervisionRequestApproval;
  PlayerSupervisionRequestApprovalWhereInput: PlayerSupervisionRequestApprovalWhereInput;
  PlayerSupervisionRequestWhereInput: PlayerSupervisionRequestWhereInput;
  PlayerWhereInput: PlayerWhereInput;
  Query: {};
  RequestPlayerSupervisionInput: RequestPlayerSupervisionInput;
  ResolvePlayerSupervisionRequestInput: ResolvePlayerSupervisionRequestInput;
  String: Scalars["String"];
  UpdateUserInput: UpdateUserInput;
  User: User;
  UserConnection: UserConnection;
  UserEdge: UserEdge;
  UserWhereInput: UserWhereInput;
}>;

export type AuthenticatedDirectiveArgs = {};

export type AuthenticatedDirectiveResolver<
  Result,
  Parent,
  ContextType = any,
  Args = AuthenticatedDirectiveArgs
> = DirectiveResolverFn<Result, Parent, ContextType, Args>;

export type GoFieldDirectiveArgs = {
  forceResolver?: Maybe<Scalars["Boolean"]>;
  name?: Maybe<Scalars["String"]>;
};

export type GoFieldDirectiveResolver<
  Result,
  Parent,
  ContextType = any,
  Args = GoFieldDirectiveArgs
> = DirectiveResolverFn<Result, Parent, ContextType, Args>;

export type GoModelDirectiveArgs = {
  model?: Maybe<Scalars["String"]>;
  models?: Maybe<Array<Scalars["String"]>>;
};

export type GoModelDirectiveResolver<
  Result,
  Parent,
  ContextType = any,
  Args = GoModelDirectiveArgs
> = DirectiveResolverFn<Result, Parent, ContextType, Args>;

export interface CursorScalarConfig
  extends GraphQLScalarTypeConfig<ResolversTypes["Cursor"], any> {
  name: "Cursor";
}

export type MutationResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["Mutation"] = ResolversParentTypes["Mutation"]
> = ResolversObject<{
  createPlayer?: Resolver<
    ResolversTypes["Player"],
    ParentType,
    ContextType,
    RequireFields<MutationCreatePlayerArgs, "input">
  >;
  requestPlayerSupervision?: Resolver<
    ResolversTypes["PlayerSupervisionRequest"],
    ParentType,
    ContextType,
    Partial<MutationRequestPlayerSupervisionArgs>
  >;
  resolvePlayerSupervisionRequest?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType,
    RequireFields<MutationResolvePlayerSupervisionRequestArgs, "input">
  >;
  updateUser?: Resolver<
    ResolversTypes["User"],
    ParentType,
    ContextType,
    RequireFields<MutationUpdateUserArgs, "id" | "input">
  >;
}>;

export type NodeResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["Node"] = ResolversParentTypes["Node"]
> = ResolversObject<{
  __resolveType: TypeResolveFn<
    | "Player"
    | "PlayerSupervisionRequest"
    | "PlayerSupervisionRequestApproval"
    | "User",
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
}>;

export type PageInfoResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["PageInfo"] = ResolversParentTypes["PageInfo"]
> = ResolversObject<{
  endCursor?: Resolver<
    Maybe<ResolversTypes["Cursor"]>,
    ParentType,
    ContextType
  >;
  hasNextPage?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  hasPreviousPage?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  startCursor?: Resolver<
    Maybe<ResolversTypes["Cursor"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PlayerResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["Player"] = ResolversParentTypes["Player"]
> = ResolversObject<{
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  owner?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  supervisionRequests?: Resolver<
    Maybe<Array<ResolversTypes["PlayerSupervisionRequest"]>>,
    ParentType,
    ContextType
  >;
  supervisors?: Resolver<
    Maybe<Array<ResolversTypes["User"]>>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PlayerConnectionResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["PlayerConnection"] = ResolversParentTypes["PlayerConnection"]
> = ResolversObject<{
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["PlayerEdge"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PlayerEdgeResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["PlayerEdge"] = ResolversParentTypes["PlayerEdge"]
> = ResolversObject<{
  cursor?: Resolver<ResolversTypes["Cursor"], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes["Player"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PlayerSupervisionRequestResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["PlayerSupervisionRequest"] = ResolversParentTypes["PlayerSupervisionRequest"]
> = ResolversObject<{
  approvals?: Resolver<
    Maybe<Array<ResolversTypes["PlayerSupervisionRequestApproval"]>>,
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  player?: Resolver<ResolversTypes["Player"], ParentType, ContextType>;
  sender?: Resolver<ResolversTypes["User"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PlayerSupervisionRequestApprovalResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["PlayerSupervisionRequestApproval"] = ResolversParentTypes["PlayerSupervisionRequestApproval"]
> = ResolversObject<{
  approved?: Resolver<
    Maybe<ResolversTypes["Boolean"]>,
    ParentType,
    ContextType
  >;
  approver?: Resolver<ResolversTypes["User"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  supervisionRequest?: Resolver<
    ResolversTypes["PlayerSupervisionRequest"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type QueryResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["Query"] = ResolversParentTypes["Query"]
> = ResolversObject<{
  getFileUploadURL?: Resolver<
    ResolversTypes["String"],
    ParentType,
    ContextType
  >;
  me?: Resolver<ResolversTypes["User"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["Node"]>,
    ParentType,
    ContextType,
    RequireFields<QueryNodeArgs, "id">
  >;
  nodes?: Resolver<
    Array<Maybe<ResolversTypes["Node"]>>,
    ParentType,
    ContextType,
    RequireFields<QueryNodesArgs, "ids">
  >;
  players?: Resolver<
    ResolversTypes["PlayerConnection"],
    ParentType,
    ContextType,
    Partial<QueryPlayersArgs>
  >;
  users?: Resolver<
    ResolversTypes["UserConnection"],
    ParentType,
    ContextType,
    Partial<QueryUsersArgs>
  >;
}>;

export type UserResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["User"] = ResolversParentTypes["User"]
> = ResolversObject<{
  avatarURL?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  email?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  mainPlayer?: Resolver<
    Maybe<ResolversTypes["Player"]>,
    ParentType,
    ContextType
  >;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  players?: Resolver<
    Maybe<Array<ResolversTypes["Player"]>>,
    ParentType,
    ContextType
  >;
  receivedSupervisionRequests?: Resolver<
    Array<ResolversTypes["PlayerSupervisionRequest"]>,
    ParentType,
    ContextType
  >;
  sentSupervisionRequests?: Resolver<
    Array<ResolversTypes["PlayerSupervisionRequest"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UserConnectionResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["UserConnection"] = ResolversParentTypes["UserConnection"]
> = ResolversObject<{
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["UserEdge"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UserEdgeResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["UserEdge"] = ResolversParentTypes["UserEdge"]
> = ResolversObject<{
  cursor?: Resolver<ResolversTypes["Cursor"], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Resolvers<ContextType = any> = ResolversObject<{
  Cursor?: GraphQLScalarType;
  Mutation?: MutationResolvers<ContextType>;
  Node?: NodeResolvers<ContextType>;
  PageInfo?: PageInfoResolvers<ContextType>;
  Player?: PlayerResolvers<ContextType>;
  PlayerConnection?: PlayerConnectionResolvers<ContextType>;
  PlayerEdge?: PlayerEdgeResolvers<ContextType>;
  PlayerSupervisionRequest?: PlayerSupervisionRequestResolvers<ContextType>;
  PlayerSupervisionRequestApproval?: PlayerSupervisionRequestApprovalResolvers<ContextType>;
  Query?: QueryResolvers<ContextType>;
  User?: UserResolvers<ContextType>;
  UserConnection?: UserConnectionResolvers<ContextType>;
  UserEdge?: UserEdgeResolvers<ContextType>;
}>;

export type DirectiveResolvers<ContextType = any> = ResolversObject<{
  authenticated?: AuthenticatedDirectiveResolver<any, any, ContextType>;
  goField?: GoFieldDirectiveResolver<any, any, ContextType>;
  goModel?: GoModelDirectiveResolver<any, any, ContextType>;
}>;
