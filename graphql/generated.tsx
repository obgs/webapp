import { gql } from "@apollo/client";
import * as Apollo from "@apollo/client";
import {
  GraphQLResolveInfo,
  GraphQLScalarType,
  GraphQLScalarTypeConfig,
} from "graphql";
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = {
  [K in keyof T]: T[K];
};
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]?: Maybe<T[SubKey]>;
};
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]: Maybe<T[SubKey]>;
};
export type RequireFields<T, K extends keyof T> = Omit<T, K> & {
  [P in K]-?: NonNullable<T[P]>;
};
const defaultOptions = {} as const;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  Cursor: any;
};

export type CreateOrUpdateGroupInput = {
  description?: InputMaybe<Scalars["String"]>;
  id?: InputMaybe<Scalars["ID"]>;
  logoUrl: Scalars["String"];
  name: Scalars["String"];
  settings: GroupSettingsInput;
};

export type CreatePlayerInput = {
  name: Scalars["String"];
};

export type Group = Node & {
  __typename?: "Group";
  applications?: Maybe<Array<GroupMembershipApplication>>;
  /** Shows if the current user already applied to the group */
  applied?: Maybe<Scalars["Boolean"]>;
  description: Scalars["String"];
  id: Scalars["ID"];
  logoURL: Scalars["String"];
  members: GroupMembershipConnection;
  name: Scalars["String"];
  /** Role of the current user in the group */
  role?: Maybe<GroupMembershipRole>;
  settings: GroupSettings;
};

export type GroupMembersArgs = {
  after?: InputMaybe<Scalars["Cursor"]>;
  before?: InputMaybe<Scalars["Cursor"]>;
  first?: InputMaybe<Scalars["Int"]>;
  last?: InputMaybe<Scalars["Int"]>;
  where?: InputMaybe<GroupMembershipWhereInput>;
};

export type GroupApplicationInput = {
  groupId: Scalars["ID"];
  message?: InputMaybe<Scalars["String"]>;
};

/** A connection to a list of items. */
export type GroupConnection = {
  __typename?: "GroupConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GroupEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"];
};

/** An edge in a connection. */
export type GroupEdge = {
  __typename?: "GroupEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["Cursor"];
  /** The item at the end of the edge. */
  node?: Maybe<Group>;
};

export type GroupMembership = Node & {
  __typename?: "GroupMembership";
  group: Group;
  id: Scalars["ID"];
  role: GroupMembershipRole;
  user: User;
};

export type GroupMembershipApplication = Node & {
  __typename?: "GroupMembershipApplication";
  group: Array<Group>;
  id: Scalars["ID"];
  message: Scalars["String"];
  user: Array<User>;
};

/** A connection to a list of items. */
export type GroupMembershipConnection = {
  __typename?: "GroupMembershipConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GroupMembershipEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"];
};

/** An edge in a connection. */
export type GroupMembershipEdge = {
  __typename?: "GroupMembershipEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["Cursor"];
  /** The item at the end of the edge. */
  node?: Maybe<GroupMembership>;
};

/** GroupMembershipRole is enum for the field role */
export enum GroupMembershipRole {
  Admin = "admin",
  Member = "member",
  Owner = "owner",
}

/**
 * GroupMembershipWhereInput is used for filtering GroupMembership objects.
 * Input was generated by ent.
 */
export type GroupMembershipWhereInput = {
  and?: InputMaybe<Array<GroupMembershipWhereInput>>;
  /** group edge predicates */
  hasGroup?: InputMaybe<Scalars["Boolean"]>;
  hasGroupWith?: InputMaybe<Array<GroupWhereInput>>;
  /** user edge predicates */
  hasUser?: InputMaybe<Scalars["Boolean"]>;
  hasUserWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars["ID"]>;
  idGT?: InputMaybe<Scalars["ID"]>;
  idGTE?: InputMaybe<Scalars["ID"]>;
  idIn?: InputMaybe<Array<Scalars["ID"]>>;
  idLT?: InputMaybe<Scalars["ID"]>;
  idLTE?: InputMaybe<Scalars["ID"]>;
  idNEQ?: InputMaybe<Scalars["ID"]>;
  idNotIn?: InputMaybe<Array<Scalars["ID"]>>;
  not?: InputMaybe<GroupMembershipWhereInput>;
  or?: InputMaybe<Array<GroupMembershipWhereInput>>;
  /** role field predicates */
  role?: InputMaybe<GroupMembershipRole>;
  roleIn?: InputMaybe<Array<GroupMembershipRole>>;
  roleNEQ?: InputMaybe<GroupMembershipRole>;
  roleNotIn?: InputMaybe<Array<GroupMembershipRole>>;
};

export type GroupSettings = Node & {
  __typename?: "GroupSettings";
  id: Scalars["ID"];
  joinPolicy: GroupSettingsJoinPolicy;
  minimumRoleToInvite?: Maybe<GroupMembershipRole>;
  visibility: GroupSettingsVisibility;
};

export type GroupSettingsInput = {
  joinPolicy: GroupSettingsJoinPolicy;
  minimumRoleToInvite?: InputMaybe<GroupMembershipRole>;
  visibility: GroupSettingsVisibility;
};

/** GroupSettingsJoinPolicy is enum for the field join_policy */
export enum GroupSettingsJoinPolicy {
  ApplicationOnly = "APPLICATION_ONLY",
  InviteOnly = "INVITE_ONLY",
  InviteOrApplication = "INVITE_OR_APPLICATION",
  Open = "OPEN",
}

/** GroupSettingsVisibility is enum for the field visibility */
export enum GroupSettingsVisibility {
  Private = "PRIVATE",
  Public = "PUBLIC",
}

/**
 * GroupSettingsWhereInput is used for filtering GroupSettings objects.
 * Input was generated by ent.
 */
export type GroupSettingsWhereInput = {
  and?: InputMaybe<Array<GroupSettingsWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars["ID"]>;
  idGT?: InputMaybe<Scalars["ID"]>;
  idGTE?: InputMaybe<Scalars["ID"]>;
  idIn?: InputMaybe<Array<Scalars["ID"]>>;
  idLT?: InputMaybe<Scalars["ID"]>;
  idLTE?: InputMaybe<Scalars["ID"]>;
  idNEQ?: InputMaybe<Scalars["ID"]>;
  idNotIn?: InputMaybe<Array<Scalars["ID"]>>;
  /** join_policy field predicates */
  joinPolicy?: InputMaybe<GroupSettingsJoinPolicy>;
  joinPolicyIn?: InputMaybe<Array<GroupSettingsJoinPolicy>>;
  joinPolicyNEQ?: InputMaybe<GroupSettingsJoinPolicy>;
  joinPolicyNotIn?: InputMaybe<Array<GroupSettingsJoinPolicy>>;
  not?: InputMaybe<GroupSettingsWhereInput>;
  or?: InputMaybe<Array<GroupSettingsWhereInput>>;
  /** visibility field predicates */
  visibility?: InputMaybe<GroupSettingsVisibility>;
  visibilityIn?: InputMaybe<Array<GroupSettingsVisibility>>;
  visibilityNEQ?: InputMaybe<GroupSettingsVisibility>;
  visibilityNotIn?: InputMaybe<Array<GroupSettingsVisibility>>;
};

/**
 * GroupWhereInput is used for filtering Group objects.
 * Input was generated by ent.
 */
export type GroupWhereInput = {
  and?: InputMaybe<Array<GroupWhereInput>>;
  /** members edge predicates */
  hasMembers?: InputMaybe<Scalars["Boolean"]>;
  hasMembersWith?: InputMaybe<Array<GroupMembershipWhereInput>>;
  /** settings edge predicates */
  hasSettings?: InputMaybe<Scalars["Boolean"]>;
  hasSettingsWith?: InputMaybe<Array<GroupSettingsWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars["ID"]>;
  idGT?: InputMaybe<Scalars["ID"]>;
  idGTE?: InputMaybe<Scalars["ID"]>;
  idIn?: InputMaybe<Array<Scalars["ID"]>>;
  idLT?: InputMaybe<Scalars["ID"]>;
  idLTE?: InputMaybe<Scalars["ID"]>;
  idNEQ?: InputMaybe<Scalars["ID"]>;
  idNotIn?: InputMaybe<Array<Scalars["ID"]>>;
  /** name field predicates */
  name?: InputMaybe<Scalars["String"]>;
  nameContains?: InputMaybe<Scalars["String"]>;
  nameContainsFold?: InputMaybe<Scalars["String"]>;
  nameEqualFold?: InputMaybe<Scalars["String"]>;
  nameGT?: InputMaybe<Scalars["String"]>;
  nameGTE?: InputMaybe<Scalars["String"]>;
  nameHasPrefix?: InputMaybe<Scalars["String"]>;
  nameHasSuffix?: InputMaybe<Scalars["String"]>;
  nameIn?: InputMaybe<Array<Scalars["String"]>>;
  nameLT?: InputMaybe<Scalars["String"]>;
  nameLTE?: InputMaybe<Scalars["String"]>;
  nameNEQ?: InputMaybe<Scalars["String"]>;
  nameNotIn?: InputMaybe<Array<Scalars["String"]>>;
  not?: InputMaybe<GroupWhereInput>;
  or?: InputMaybe<Array<GroupWhereInput>>;
};

export type Mutation = {
  __typename?: "Mutation";
  applyToGroup: GroupMembershipApplication;
  createOrUpdateGroup: Group;
  createPlayer: Player;
  joinGroup: Scalars["Boolean"];
  requestPlayerSupervision: PlayerSupervisionRequest;
  resolvePlayerSupervisionRequest: Scalars["Boolean"];
  updateUser: User;
};

export type MutationApplyToGroupArgs = {
  input: GroupApplicationInput;
};

export type MutationCreateOrUpdateGroupArgs = {
  input: CreateOrUpdateGroupInput;
};

export type MutationCreatePlayerArgs = {
  input: CreatePlayerInput;
};

export type MutationJoinGroupArgs = {
  groupId: Scalars["ID"];
};

export type MutationRequestPlayerSupervisionArgs = {
  input?: InputMaybe<RequestPlayerSupervisionInput>;
};

export type MutationResolvePlayerSupervisionRequestArgs = {
  input: ResolvePlayerSupervisionRequestInput;
};

export type MutationUpdateUserArgs = {
  id: Scalars["ID"];
  input: UpdateUserInput;
};

/**
 * An object with an ID.
 * Follows the [Relay Global Object Identification Specification](https://relay.dev/graphql/objectidentification.htm)
 */
export type Node = {
  /** The id of the object. */
  id: Scalars["ID"];
};

/** Possible directions in which to order a list of items when provided an `orderBy` argument. */
export enum OrderDirection {
  /** Specifies an ascending order for a given `orderBy` argument. */
  Asc = "ASC",
  /** Specifies a descending order for a given `orderBy` argument. */
  Desc = "DESC",
}

/**
 * Information about pagination in a connection.
 * https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo
 */
export type PageInfo = {
  __typename?: "PageInfo";
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars["Cursor"]>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars["Boolean"];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars["Boolean"];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars["Cursor"]>;
};

export type Player = Node & {
  __typename?: "Player";
  id: Scalars["ID"];
  name: Scalars["String"];
  owner?: Maybe<User>;
  supervisionRequests?: Maybe<Array<PlayerSupervisionRequest>>;
  supervisors?: Maybe<Array<User>>;
};

/** A connection to a list of items. */
export type PlayerConnection = {
  __typename?: "PlayerConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PlayerEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"];
};

/** An edge in a connection. */
export type PlayerEdge = {
  __typename?: "PlayerEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["Cursor"];
  /** The item at the end of the edge. */
  node?: Maybe<Player>;
};

export type PlayerSupervisionRequest = Node & {
  __typename?: "PlayerSupervisionRequest";
  approvals?: Maybe<Array<PlayerSupervisionRequestApproval>>;
  id: Scalars["ID"];
  message?: Maybe<Scalars["String"]>;
  player: Player;
  sender: User;
};

export type PlayerSupervisionRequestApproval = Node & {
  __typename?: "PlayerSupervisionRequestApproval";
  approved?: Maybe<Scalars["Boolean"]>;
  approver: User;
  id: Scalars["ID"];
  supervisionRequest: PlayerSupervisionRequest;
};

/**
 * PlayerSupervisionRequestApprovalWhereInput is used for filtering PlayerSupervisionRequestApproval objects.
 * Input was generated by ent.
 */
export type PlayerSupervisionRequestApprovalWhereInput = {
  and?: InputMaybe<Array<PlayerSupervisionRequestApprovalWhereInput>>;
  /** approved field predicates */
  approved?: InputMaybe<Scalars["Boolean"]>;
  approvedIsNil?: InputMaybe<Scalars["Boolean"]>;
  approvedNEQ?: InputMaybe<Scalars["Boolean"]>;
  approvedNotNil?: InputMaybe<Scalars["Boolean"]>;
  /** approver edge predicates */
  hasApprover?: InputMaybe<Scalars["Boolean"]>;
  hasApproverWith?: InputMaybe<Array<UserWhereInput>>;
  /** supervision_request edge predicates */
  hasSupervisionRequest?: InputMaybe<Scalars["Boolean"]>;
  hasSupervisionRequestWith?: InputMaybe<
    Array<PlayerSupervisionRequestWhereInput>
  >;
  /** id field predicates */
  id?: InputMaybe<Scalars["ID"]>;
  idGT?: InputMaybe<Scalars["ID"]>;
  idGTE?: InputMaybe<Scalars["ID"]>;
  idIn?: InputMaybe<Array<Scalars["ID"]>>;
  idLT?: InputMaybe<Scalars["ID"]>;
  idLTE?: InputMaybe<Scalars["ID"]>;
  idNEQ?: InputMaybe<Scalars["ID"]>;
  idNotIn?: InputMaybe<Array<Scalars["ID"]>>;
  not?: InputMaybe<PlayerSupervisionRequestApprovalWhereInput>;
  or?: InputMaybe<Array<PlayerSupervisionRequestApprovalWhereInput>>;
};

/**
 * PlayerSupervisionRequestWhereInput is used for filtering PlayerSupervisionRequest objects.
 * Input was generated by ent.
 */
export type PlayerSupervisionRequestWhereInput = {
  and?: InputMaybe<Array<PlayerSupervisionRequestWhereInput>>;
  /** approvals edge predicates */
  hasApprovals?: InputMaybe<Scalars["Boolean"]>;
  hasApprovalsWith?: InputMaybe<
    Array<PlayerSupervisionRequestApprovalWhereInput>
  >;
  /** player edge predicates */
  hasPlayer?: InputMaybe<Scalars["Boolean"]>;
  hasPlayerWith?: InputMaybe<Array<PlayerWhereInput>>;
  /** sender edge predicates */
  hasSender?: InputMaybe<Scalars["Boolean"]>;
  hasSenderWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars["ID"]>;
  idGT?: InputMaybe<Scalars["ID"]>;
  idGTE?: InputMaybe<Scalars["ID"]>;
  idIn?: InputMaybe<Array<Scalars["ID"]>>;
  idLT?: InputMaybe<Scalars["ID"]>;
  idLTE?: InputMaybe<Scalars["ID"]>;
  idNEQ?: InputMaybe<Scalars["ID"]>;
  idNotIn?: InputMaybe<Array<Scalars["ID"]>>;
  not?: InputMaybe<PlayerSupervisionRequestWhereInput>;
  or?: InputMaybe<Array<PlayerSupervisionRequestWhereInput>>;
};

/**
 * PlayerWhereInput is used for filtering Player objects.
 * Input was generated by ent.
 */
export type PlayerWhereInput = {
  and?: InputMaybe<Array<PlayerWhereInput>>;
  /** owner edge predicates */
  hasOwner?: InputMaybe<Scalars["Boolean"]>;
  hasOwnerWith?: InputMaybe<Array<UserWhereInput>>;
  /** supervision_requests edge predicates */
  hasSupervisionRequests?: InputMaybe<Scalars["Boolean"]>;
  hasSupervisionRequestsWith?: InputMaybe<
    Array<PlayerSupervisionRequestWhereInput>
  >;
  /** supervisors edge predicates */
  hasSupervisors?: InputMaybe<Scalars["Boolean"]>;
  hasSupervisorsWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars["ID"]>;
  idGT?: InputMaybe<Scalars["ID"]>;
  idGTE?: InputMaybe<Scalars["ID"]>;
  idIn?: InputMaybe<Array<Scalars["ID"]>>;
  idLT?: InputMaybe<Scalars["ID"]>;
  idLTE?: InputMaybe<Scalars["ID"]>;
  idNEQ?: InputMaybe<Scalars["ID"]>;
  idNotIn?: InputMaybe<Array<Scalars["ID"]>>;
  /** name field predicates */
  name?: InputMaybe<Scalars["String"]>;
  nameContains?: InputMaybe<Scalars["String"]>;
  nameContainsFold?: InputMaybe<Scalars["String"]>;
  nameEqualFold?: InputMaybe<Scalars["String"]>;
  nameGT?: InputMaybe<Scalars["String"]>;
  nameGTE?: InputMaybe<Scalars["String"]>;
  nameHasPrefix?: InputMaybe<Scalars["String"]>;
  nameHasSuffix?: InputMaybe<Scalars["String"]>;
  nameIn?: InputMaybe<Array<Scalars["String"]>>;
  nameLT?: InputMaybe<Scalars["String"]>;
  nameLTE?: InputMaybe<Scalars["String"]>;
  nameNEQ?: InputMaybe<Scalars["String"]>;
  nameNotIn?: InputMaybe<Array<Scalars["String"]>>;
  not?: InputMaybe<PlayerWhereInput>;
  or?: InputMaybe<Array<PlayerWhereInput>>;
};

export type Query = {
  __typename?: "Query";
  getFileUploadURL: Scalars["String"];
  groups: GroupConnection;
  me: User;
  /** Fetches an object given its ID. */
  node?: Maybe<Node>;
  /** Lookup nodes by a list of IDs. */
  nodes: Array<Maybe<Node>>;
  players: PlayerConnection;
  users: UserConnection;
};

export type QueryGroupsArgs = {
  after?: InputMaybe<Scalars["Cursor"]>;
  before?: InputMaybe<Scalars["Cursor"]>;
  first?: InputMaybe<Scalars["Int"]>;
  last?: InputMaybe<Scalars["Int"]>;
  where?: InputMaybe<GroupWhereInput>;
};

export type QueryNodeArgs = {
  id: Scalars["ID"];
};

export type QueryNodesArgs = {
  ids: Array<Scalars["ID"]>;
};

export type QueryPlayersArgs = {
  after?: InputMaybe<Scalars["Cursor"]>;
  before?: InputMaybe<Scalars["Cursor"]>;
  first?: InputMaybe<Scalars["Int"]>;
  last?: InputMaybe<Scalars["Int"]>;
  where?: InputMaybe<PlayerWhereInput>;
};

export type QueryUsersArgs = {
  after?: InputMaybe<Scalars["Cursor"]>;
  before?: InputMaybe<Scalars["Cursor"]>;
  first?: InputMaybe<Scalars["Int"]>;
  last?: InputMaybe<Scalars["Int"]>;
  where?: InputMaybe<UserWhereInput>;
};

export type RequestPlayerSupervisionInput = {
  message?: InputMaybe<Scalars["String"]>;
  playerId: Scalars["ID"];
};

export type ResolvePlayerSupervisionRequestInput = {
  approved: Scalars["Boolean"];
  requestId: Scalars["ID"];
};

/**
 * UpdateUserInput is used for update User object.
 * Input was generated by ent.
 */
export type UpdateUserInput = {
  addPlayerIDs?: InputMaybe<Array<Scalars["ID"]>>;
  avatarURL?: InputMaybe<Scalars["String"]>;
  clearMainPlayer?: InputMaybe<Scalars["Boolean"]>;
  email?: InputMaybe<Scalars["String"]>;
  mainPlayerID?: InputMaybe<Scalars["ID"]>;
  name?: InputMaybe<Scalars["String"]>;
  removePlayerIDs?: InputMaybe<Array<Scalars["ID"]>>;
};

export type User = Node & {
  __typename?: "User";
  avatarURL: Scalars["String"];
  email: Scalars["String"];
  groupMembershipApplications?: Maybe<Array<GroupMembershipApplication>>;
  groupMemberships?: Maybe<Array<GroupMembership>>;
  id: Scalars["ID"];
  mainPlayer?: Maybe<Player>;
  name: Scalars["String"];
  players?: Maybe<Array<Player>>;
  receivedSupervisionRequests: Array<PlayerSupervisionRequest>;
  sentSupervisionRequests: Array<PlayerSupervisionRequest>;
};

/** A connection to a list of items. */
export type UserConnection = {
  __typename?: "UserConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<UserEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars["Int"];
};

/** An edge in a connection. */
export type UserEdge = {
  __typename?: "UserEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["Cursor"];
  /** The item at the end of the edge. */
  node?: Maybe<User>;
};

/**
 * UserWhereInput is used for filtering User objects.
 * Input was generated by ent.
 */
export type UserWhereInput = {
  and?: InputMaybe<Array<UserWhereInput>>;
  /** email field predicates */
  email?: InputMaybe<Scalars["String"]>;
  emailContains?: InputMaybe<Scalars["String"]>;
  emailContainsFold?: InputMaybe<Scalars["String"]>;
  emailEqualFold?: InputMaybe<Scalars["String"]>;
  emailGT?: InputMaybe<Scalars["String"]>;
  emailGTE?: InputMaybe<Scalars["String"]>;
  emailHasPrefix?: InputMaybe<Scalars["String"]>;
  emailHasSuffix?: InputMaybe<Scalars["String"]>;
  emailIn?: InputMaybe<Array<Scalars["String"]>>;
  emailLT?: InputMaybe<Scalars["String"]>;
  emailLTE?: InputMaybe<Scalars["String"]>;
  emailNEQ?: InputMaybe<Scalars["String"]>;
  emailNotIn?: InputMaybe<Array<Scalars["String"]>>;
  /** group_memberships edge predicates */
  hasGroupMemberships?: InputMaybe<Scalars["Boolean"]>;
  hasGroupMembershipsWith?: InputMaybe<Array<GroupMembershipWhereInput>>;
  /** main_player edge predicates */
  hasMainPlayer?: InputMaybe<Scalars["Boolean"]>;
  hasMainPlayerWith?: InputMaybe<Array<PlayerWhereInput>>;
  /** players edge predicates */
  hasPlayers?: InputMaybe<Scalars["Boolean"]>;
  hasPlayersWith?: InputMaybe<Array<PlayerWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars["ID"]>;
  idGT?: InputMaybe<Scalars["ID"]>;
  idGTE?: InputMaybe<Scalars["ID"]>;
  idIn?: InputMaybe<Array<Scalars["ID"]>>;
  idLT?: InputMaybe<Scalars["ID"]>;
  idLTE?: InputMaybe<Scalars["ID"]>;
  idNEQ?: InputMaybe<Scalars["ID"]>;
  idNotIn?: InputMaybe<Array<Scalars["ID"]>>;
  /** name field predicates */
  name?: InputMaybe<Scalars["String"]>;
  nameContains?: InputMaybe<Scalars["String"]>;
  nameContainsFold?: InputMaybe<Scalars["String"]>;
  nameEqualFold?: InputMaybe<Scalars["String"]>;
  nameGT?: InputMaybe<Scalars["String"]>;
  nameGTE?: InputMaybe<Scalars["String"]>;
  nameHasPrefix?: InputMaybe<Scalars["String"]>;
  nameHasSuffix?: InputMaybe<Scalars["String"]>;
  nameIn?: InputMaybe<Array<Scalars["String"]>>;
  nameLT?: InputMaybe<Scalars["String"]>;
  nameLTE?: InputMaybe<Scalars["String"]>;
  nameNEQ?: InputMaybe<Scalars["String"]>;
  nameNotIn?: InputMaybe<Array<Scalars["String"]>>;
  not?: InputMaybe<UserWhereInput>;
  or?: InputMaybe<Array<UserWhereInput>>;
};

export type GroupFieldsFragment = {
  __typename?: "Group";
  id: string;
  name: string;
  description: string;
  logoURL: string;
  role?: GroupMembershipRole | null;
  applied?: boolean | null;
  settings: {
    __typename?: "GroupSettings";
    id: string;
    visibility: GroupSettingsVisibility;
    joinPolicy: GroupSettingsJoinPolicy;
    minimumRoleToInvite?: GroupMembershipRole | null;
  };
  members: { __typename?: "GroupMembershipConnection"; totalCount: number };
};

export type GroupMembershipApplicationFieldsFragment = {
  __typename?: "GroupMembershipApplication";
  id: string;
  message: string;
  user: Array<{
    __typename?: "User";
    id: string;
    name: string;
    email: string;
    avatarURL: string;
  }>;
  group: Array<{
    __typename?: "Group";
    id: string;
    name: string;
    description: string;
    logoURL: string;
    role?: GroupMembershipRole | null;
    applied?: boolean | null;
    settings: {
      __typename?: "GroupSettings";
      id: string;
      visibility: GroupSettingsVisibility;
      joinPolicy: GroupSettingsJoinPolicy;
      minimumRoleToInvite?: GroupMembershipRole | null;
    };
    members: { __typename?: "GroupMembershipConnection"; totalCount: number };
  }>;
};

export type PageInfoFieldsFragment = {
  __typename?: "PageInfo";
  hasNextPage: boolean;
  hasPreviousPage: boolean;
  startCursor?: any | null;
  endCursor?: any | null;
};

export type PlayerFieldsFragment = {
  __typename?: "Player";
  id: string;
  name: string;
  owner?: { __typename?: "User"; id: string; name: string } | null;
  supervisors?: Array<{ __typename?: "User"; id: string; name: string }> | null;
};

export type PlayerSupervisionRequestFieldsFragment = {
  __typename?: "PlayerSupervisionRequest";
  id: string;
  message?: string | null;
  sender: { __typename?: "User"; id: string; name: string; avatarURL: string };
  player: {
    __typename?: "Player";
    id: string;
    name: string;
    owner?: { __typename?: "User"; id: string; name: string } | null;
    supervisors?: Array<{
      __typename?: "User";
      id: string;
      name: string;
    }> | null;
  };
  approvals?: Array<{
    __typename?: "PlayerSupervisionRequestApproval";
    approved?: boolean | null;
    approver: {
      __typename?: "User";
      id: string;
      name: string;
      avatarURL: string;
    };
  }> | null;
};

export type UserFieldsFragment = {
  __typename?: "User";
  id: string;
  name: string;
  email: string;
  avatarURL: string;
};

export type ApplyToGroupMutationVariables = Exact<{
  input: GroupApplicationInput;
}>;

export type ApplyToGroupMutation = {
  __typename?: "Mutation";
  applyToGroup: {
    __typename?: "GroupMembershipApplication";
    id: string;
    message: string;
    user: Array<{
      __typename?: "User";
      id: string;
      name: string;
      email: string;
      avatarURL: string;
    }>;
    group: Array<{
      __typename?: "Group";
      id: string;
      name: string;
      description: string;
      logoURL: string;
      role?: GroupMembershipRole | null;
      applied?: boolean | null;
      settings: {
        __typename?: "GroupSettings";
        id: string;
        visibility: GroupSettingsVisibility;
        joinPolicy: GroupSettingsJoinPolicy;
        minimumRoleToInvite?: GroupMembershipRole | null;
      };
      members: { __typename?: "GroupMembershipConnection"; totalCount: number };
    }>;
  };
};

export type CreateOrUpdateGroupMutationVariables = Exact<{
  id?: InputMaybe<Scalars["ID"]>;
  name: Scalars["String"];
  description?: InputMaybe<Scalars["String"]>;
  logoUrl: Scalars["String"];
  visibility: GroupSettingsVisibility;
  joinPolicy: GroupSettingsJoinPolicy;
  minimumRoleToInvite?: InputMaybe<GroupMembershipRole>;
}>;

export type CreateOrUpdateGroupMutation = {
  __typename?: "Mutation";
  createOrUpdateGroup: {
    __typename?: "Group";
    id: string;
    name: string;
    description: string;
    logoURL: string;
    role?: GroupMembershipRole | null;
    applied?: boolean | null;
    settings: {
      __typename?: "GroupSettings";
      id: string;
      visibility: GroupSettingsVisibility;
      joinPolicy: GroupSettingsJoinPolicy;
      minimumRoleToInvite?: GroupMembershipRole | null;
    };
    members: { __typename?: "GroupMembershipConnection"; totalCount: number };
  };
};

export type CreatePlayerMutationVariables = Exact<{
  name: Scalars["String"];
}>;

export type CreatePlayerMutation = {
  __typename?: "Mutation";
  createPlayer: { __typename?: "Player"; id: string; name: string };
};

export type JoinGroupMutationVariables = Exact<{
  id: Scalars["ID"];
}>;

export type JoinGroupMutation = { __typename?: "Mutation"; joinGroup: boolean };

export type RequestPlayerSupervisionMutationVariables = Exact<{
  input: RequestPlayerSupervisionInput;
}>;

export type RequestPlayerSupervisionMutation = {
  __typename?: "Mutation";
  requestPlayerSupervision: {
    __typename?: "PlayerSupervisionRequest";
    id: string;
  };
};

export type ResolvePlayerSupervisionRequestMutationVariables = Exact<{
  input: ResolvePlayerSupervisionRequestInput;
}>;

export type ResolvePlayerSupervisionRequestMutation = {
  __typename?: "Mutation";
  resolvePlayerSupervisionRequest: boolean;
};

export type UpdateUserMutationVariables = Exact<{
  id: Scalars["ID"];
  input: UpdateUserInput;
}>;

export type UpdateUserMutation = {
  __typename?: "Mutation";
  updateUser: { __typename?: "User"; id: string };
};

export type GetFileUploadUrlQueryVariables = Exact<{ [key: string]: never }>;

export type GetFileUploadUrlQuery = {
  __typename?: "Query";
  getFileUploadURL: string;
};

export type GroupQueryVariables = Exact<{
  id: Scalars["ID"];
}>;

export type GroupQuery = {
  __typename?: "Query";
  node?:
    | {
        __typename?: "Group";
        id: string;
        name: string;
        description: string;
        logoURL: string;
        role?: GroupMembershipRole | null;
        applied?: boolean | null;
        settings: {
          __typename?: "GroupSettings";
          id: string;
          visibility: GroupSettingsVisibility;
          joinPolicy: GroupSettingsJoinPolicy;
          minimumRoleToInvite?: GroupMembershipRole | null;
        };
        members: {
          __typename?: "GroupMembershipConnection";
          totalCount: number;
        };
      }
    | { __typename?: "GroupMembership" }
    | { __typename?: "GroupMembershipApplication" }
    | { __typename?: "GroupSettings" }
    | { __typename?: "Player" }
    | { __typename?: "PlayerSupervisionRequest" }
    | { __typename?: "PlayerSupervisionRequestApproval" }
    | { __typename?: "User" }
    | null;
};

export type GroupMembersQueryVariables = Exact<{
  groupId: Scalars["ID"];
  before?: InputMaybe<Scalars["Cursor"]>;
  after?: InputMaybe<Scalars["Cursor"]>;
  first?: InputMaybe<Scalars["Int"]>;
  last?: InputMaybe<Scalars["Int"]>;
  where?: InputMaybe<GroupMembershipWhereInput>;
}>;

export type GroupMembersQuery = {
  __typename?: "Query";
  node?:
    | {
        __typename?: "Group";
        members: {
          __typename?: "GroupMembershipConnection";
          totalCount: number;
          pageInfo: {
            __typename?: "PageInfo";
            hasNextPage: boolean;
            hasPreviousPage: boolean;
            startCursor?: any | null;
            endCursor?: any | null;
          };
          edges?: Array<{
            __typename?: "GroupMembershipEdge";
            node?: {
              __typename?: "GroupMembership";
              id: string;
              role: GroupMembershipRole;
              user: {
                __typename?: "User";
                id: string;
                name: string;
                email: string;
                avatarURL: string;
              };
            } | null;
          } | null> | null;
        };
      }
    | { __typename?: "GroupMembership" }
    | { __typename?: "GroupMembershipApplication" }
    | { __typename?: "GroupSettings" }
    | { __typename?: "Player" }
    | { __typename?: "PlayerSupervisionRequest" }
    | { __typename?: "PlayerSupervisionRequestApproval" }
    | { __typename?: "User" }
    | null;
};

export type GroupSettingsQueryVariables = Exact<{
  id: Scalars["ID"];
}>;

export type GroupSettingsQuery = {
  __typename?: "Query";
  node?:
    | {
        __typename?: "Group";
        id: string;
        name: string;
        description: string;
        logoURL: string;
        settings: {
          __typename?: "GroupSettings";
          id: string;
          visibility: GroupSettingsVisibility;
          joinPolicy: GroupSettingsJoinPolicy;
          minimumRoleToInvite?: GroupMembershipRole | null;
        };
      }
    | { __typename?: "GroupMembership" }
    | { __typename?: "GroupMembershipApplication" }
    | { __typename?: "GroupSettings" }
    | { __typename?: "Player" }
    | { __typename?: "PlayerSupervisionRequest" }
    | { __typename?: "PlayerSupervisionRequestApproval" }
    | { __typename?: "User" }
    | null;
};

export type IncomingSupervisionRequestsQueryVariables = Exact<{
  [key: string]: never;
}>;

export type IncomingSupervisionRequestsQuery = {
  __typename?: "Query";
  me: {
    __typename?: "User";
    receivedSupervisionRequests: Array<{
      __typename?: "PlayerSupervisionRequest";
      id: string;
      message?: string | null;
      sender: {
        __typename?: "User";
        id: string;
        name: string;
        avatarURL: string;
      };
      player: {
        __typename?: "Player";
        id: string;
        name: string;
        owner?: { __typename?: "User"; id: string; name: string } | null;
        supervisors?: Array<{
          __typename?: "User";
          id: string;
          name: string;
        }> | null;
      };
      approvals?: Array<{
        __typename?: "PlayerSupervisionRequestApproval";
        approved?: boolean | null;
        approver: {
          __typename?: "User";
          id: string;
          name: string;
          avatarURL: string;
        };
      }> | null;
    }>;
  };
};

export type MeQueryVariables = Exact<{ [key: string]: never }>;

export type MeQuery = {
  __typename?: "Query";
  me: {
    __typename?: "User";
    id: string;
    name: string;
    email: string;
    avatarURL: string;
  };
};

export type MyPlayersQueryVariables = Exact<{ [key: string]: never }>;

export type MyPlayersQuery = {
  __typename?: "Query";
  me: {
    __typename?: "User";
    players?: Array<{
      __typename?: "Player";
      id: string;
      name: string;
      owner?: { __typename?: "User"; id: string; name: string } | null;
      supervisors?: Array<{
        __typename?: "User";
        id: string;
        name: string;
      }> | null;
    }> | null;
  };
};

export type PendingSupervisionRequestsQueryVariables = Exact<{
  [key: string]: never;
}>;

export type PendingSupervisionRequestsQuery = {
  __typename?: "Query";
  me: {
    __typename?: "User";
    sentSupervisionRequests: Array<{
      __typename?: "PlayerSupervisionRequest";
      id: string;
      message?: string | null;
      sender: {
        __typename?: "User";
        id: string;
        name: string;
        avatarURL: string;
      };
      player: {
        __typename?: "Player";
        id: string;
        name: string;
        owner?: { __typename?: "User"; id: string; name: string } | null;
        supervisors?: Array<{
          __typename?: "User";
          id: string;
          name: string;
        }> | null;
      };
      approvals?: Array<{
        __typename?: "PlayerSupervisionRequestApproval";
        approved?: boolean | null;
        approver: {
          __typename?: "User";
          id: string;
          name: string;
          avatarURL: string;
        };
      }> | null;
    }>;
  };
};

export type SearchGroupsQueryVariables = Exact<{
  before?: InputMaybe<Scalars["Cursor"]>;
  after?: InputMaybe<Scalars["Cursor"]>;
  where: GroupWhereInput;
  first?: InputMaybe<Scalars["Int"]>;
  last?: InputMaybe<Scalars["Int"]>;
}>;

export type SearchGroupsQuery = {
  __typename?: "Query";
  groups: {
    __typename?: "GroupConnection";
    totalCount: number;
    pageInfo: {
      __typename?: "PageInfo";
      hasNextPage: boolean;
      hasPreviousPage: boolean;
      startCursor?: any | null;
      endCursor?: any | null;
    };
    edges?: Array<{
      __typename?: "GroupEdge";
      node?: {
        __typename?: "Group";
        id: string;
        name: string;
        description: string;
        logoURL: string;
        role?: GroupMembershipRole | null;
        applied?: boolean | null;
        settings: {
          __typename?: "GroupSettings";
          id: string;
          visibility: GroupSettingsVisibility;
          joinPolicy: GroupSettingsJoinPolicy;
          minimumRoleToInvite?: GroupMembershipRole | null;
        };
        members: {
          __typename?: "GroupMembershipConnection";
          totalCount: number;
        };
      } | null;
    } | null> | null;
  };
};

export type SearchPlayersQueryVariables = Exact<{
  before?: InputMaybe<Scalars["Cursor"]>;
  after?: InputMaybe<Scalars["Cursor"]>;
  where: PlayerWhereInput;
  first?: InputMaybe<Scalars["Int"]>;
  last?: InputMaybe<Scalars["Int"]>;
}>;

export type SearchPlayersQuery = {
  __typename?: "Query";
  players: {
    __typename?: "PlayerConnection";
    totalCount: number;
    pageInfo: {
      __typename?: "PageInfo";
      hasNextPage: boolean;
      hasPreviousPage: boolean;
      startCursor?: any | null;
      endCursor?: any | null;
    };
    edges?: Array<{
      __typename?: "PlayerEdge";
      cursor: any;
      node?: {
        __typename?: "Player";
        id: string;
        name: string;
        owner?: { __typename?: "User"; id: string; name: string } | null;
        supervisors?: Array<{
          __typename?: "User";
          id: string;
          name: string;
        }> | null;
      } | null;
    } | null> | null;
  };
};

export const UserFieldsFragmentDoc = gql`
  fragment userFields on User {
    id
    name
    email
    avatarURL
  }
`;
export const GroupFieldsFragmentDoc = gql`
  fragment groupFields on Group {
    id
    name
    description
    logoURL
    settings {
      id
      visibility
      joinPolicy
      minimumRoleToInvite
    }
    members {
      totalCount
    }
    role
    applied
  }
`;
export const GroupMembershipApplicationFieldsFragmentDoc = gql`
  fragment groupMembershipApplicationFields on GroupMembershipApplication {
    id
    message
    user {
      ...userFields
    }
    group {
      ...groupFields
    }
  }
  ${UserFieldsFragmentDoc}
  ${GroupFieldsFragmentDoc}
`;
export const PageInfoFieldsFragmentDoc = gql`
  fragment pageInfoFields on PageInfo {
    hasNextPage
    hasPreviousPage
    startCursor
    endCursor
  }
`;
export const PlayerFieldsFragmentDoc = gql`
  fragment playerFields on Player {
    id
    name
    owner {
      id
      name
    }
    supervisors {
      id
      name
    }
  }
`;
export const PlayerSupervisionRequestFieldsFragmentDoc = gql`
  fragment playerSupervisionRequestFields on PlayerSupervisionRequest {
    id
    message
    sender {
      id
      name
      avatarURL
    }
    player {
      ...playerFields
    }
    approvals {
      approved
      approver {
        id
        name
        avatarURL
      }
    }
  }
  ${PlayerFieldsFragmentDoc}
`;
export const ApplyToGroupDocument = gql`
  mutation ApplyToGroup($input: GroupApplicationInput!) {
    applyToGroup(input: $input) {
      ...groupMembershipApplicationFields
    }
  }
  ${GroupMembershipApplicationFieldsFragmentDoc}
`;
export type ApplyToGroupMutationFn = Apollo.MutationFunction<
  ApplyToGroupMutation,
  ApplyToGroupMutationVariables
>;

/**
 * __useApplyToGroupMutation__
 *
 * To run a mutation, you first call `useApplyToGroupMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useApplyToGroupMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [applyToGroupMutation, { data, loading, error }] = useApplyToGroupMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useApplyToGroupMutation(
  baseOptions?: Apollo.MutationHookOptions<
    ApplyToGroupMutation,
    ApplyToGroupMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useMutation<
    ApplyToGroupMutation,
    ApplyToGroupMutationVariables
  >(ApplyToGroupDocument, options);
}
export type ApplyToGroupMutationHookResult = ReturnType<
  typeof useApplyToGroupMutation
>;
export type ApplyToGroupMutationResult =
  Apollo.MutationResult<ApplyToGroupMutation>;
export type ApplyToGroupMutationOptions = Apollo.BaseMutationOptions<
  ApplyToGroupMutation,
  ApplyToGroupMutationVariables
>;
export const CreateOrUpdateGroupDocument = gql`
  mutation CreateOrUpdateGroup(
    $id: ID
    $name: String!
    $description: String
    $logoUrl: String!
    $visibility: GroupSettingsVisibility!
    $joinPolicy: GroupSettingsJoinPolicy!
    $minimumRoleToInvite: GroupMembershipRole
  ) {
    createOrUpdateGroup(
      input: {
        id: $id
        name: $name
        description: $description
        logoUrl: $logoUrl
        settings: {
          visibility: $visibility
          joinPolicy: $joinPolicy
          minimumRoleToInvite: $minimumRoleToInvite
        }
      }
    ) {
      ...groupFields
    }
  }
  ${GroupFieldsFragmentDoc}
`;
export type CreateOrUpdateGroupMutationFn = Apollo.MutationFunction<
  CreateOrUpdateGroupMutation,
  CreateOrUpdateGroupMutationVariables
>;

/**
 * __useCreateOrUpdateGroupMutation__
 *
 * To run a mutation, you first call `useCreateOrUpdateGroupMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateOrUpdateGroupMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createOrUpdateGroupMutation, { data, loading, error }] = useCreateOrUpdateGroupMutation({
 *   variables: {
 *      id: // value for 'id'
 *      name: // value for 'name'
 *      description: // value for 'description'
 *      logoUrl: // value for 'logoUrl'
 *      visibility: // value for 'visibility'
 *      joinPolicy: // value for 'joinPolicy'
 *      minimumRoleToInvite: // value for 'minimumRoleToInvite'
 *   },
 * });
 */
export function useCreateOrUpdateGroupMutation(
  baseOptions?: Apollo.MutationHookOptions<
    CreateOrUpdateGroupMutation,
    CreateOrUpdateGroupMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useMutation<
    CreateOrUpdateGroupMutation,
    CreateOrUpdateGroupMutationVariables
  >(CreateOrUpdateGroupDocument, options);
}
export type CreateOrUpdateGroupMutationHookResult = ReturnType<
  typeof useCreateOrUpdateGroupMutation
>;
export type CreateOrUpdateGroupMutationResult =
  Apollo.MutationResult<CreateOrUpdateGroupMutation>;
export type CreateOrUpdateGroupMutationOptions = Apollo.BaseMutationOptions<
  CreateOrUpdateGroupMutation,
  CreateOrUpdateGroupMutationVariables
>;
export const CreatePlayerDocument = gql`
  mutation CreatePlayer($name: String!) {
    createPlayer(input: { name: $name }) {
      id
      name
    }
  }
`;
export type CreatePlayerMutationFn = Apollo.MutationFunction<
  CreatePlayerMutation,
  CreatePlayerMutationVariables
>;

/**
 * __useCreatePlayerMutation__
 *
 * To run a mutation, you first call `useCreatePlayerMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreatePlayerMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createPlayerMutation, { data, loading, error }] = useCreatePlayerMutation({
 *   variables: {
 *      name: // value for 'name'
 *   },
 * });
 */
export function useCreatePlayerMutation(
  baseOptions?: Apollo.MutationHookOptions<
    CreatePlayerMutation,
    CreatePlayerMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useMutation<
    CreatePlayerMutation,
    CreatePlayerMutationVariables
  >(CreatePlayerDocument, options);
}
export type CreatePlayerMutationHookResult = ReturnType<
  typeof useCreatePlayerMutation
>;
export type CreatePlayerMutationResult =
  Apollo.MutationResult<CreatePlayerMutation>;
export type CreatePlayerMutationOptions = Apollo.BaseMutationOptions<
  CreatePlayerMutation,
  CreatePlayerMutationVariables
>;
export const JoinGroupDocument = gql`
  mutation JoinGroup($id: ID!) {
    joinGroup(groupId: $id)
  }
`;
export type JoinGroupMutationFn = Apollo.MutationFunction<
  JoinGroupMutation,
  JoinGroupMutationVariables
>;

/**
 * __useJoinGroupMutation__
 *
 * To run a mutation, you first call `useJoinGroupMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useJoinGroupMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [joinGroupMutation, { data, loading, error }] = useJoinGroupMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useJoinGroupMutation(
  baseOptions?: Apollo.MutationHookOptions<
    JoinGroupMutation,
    JoinGroupMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useMutation<JoinGroupMutation, JoinGroupMutationVariables>(
    JoinGroupDocument,
    options
  );
}
export type JoinGroupMutationHookResult = ReturnType<
  typeof useJoinGroupMutation
>;
export type JoinGroupMutationResult = Apollo.MutationResult<JoinGroupMutation>;
export type JoinGroupMutationOptions = Apollo.BaseMutationOptions<
  JoinGroupMutation,
  JoinGroupMutationVariables
>;
export const RequestPlayerSupervisionDocument = gql`
  mutation RequestPlayerSupervision($input: RequestPlayerSupervisionInput!) {
    requestPlayerSupervision(input: $input) {
      id
    }
  }
`;
export type RequestPlayerSupervisionMutationFn = Apollo.MutationFunction<
  RequestPlayerSupervisionMutation,
  RequestPlayerSupervisionMutationVariables
>;

/**
 * __useRequestPlayerSupervisionMutation__
 *
 * To run a mutation, you first call `useRequestPlayerSupervisionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRequestPlayerSupervisionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [requestPlayerSupervisionMutation, { data, loading, error }] = useRequestPlayerSupervisionMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useRequestPlayerSupervisionMutation(
  baseOptions?: Apollo.MutationHookOptions<
    RequestPlayerSupervisionMutation,
    RequestPlayerSupervisionMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useMutation<
    RequestPlayerSupervisionMutation,
    RequestPlayerSupervisionMutationVariables
  >(RequestPlayerSupervisionDocument, options);
}
export type RequestPlayerSupervisionMutationHookResult = ReturnType<
  typeof useRequestPlayerSupervisionMutation
>;
export type RequestPlayerSupervisionMutationResult =
  Apollo.MutationResult<RequestPlayerSupervisionMutation>;
export type RequestPlayerSupervisionMutationOptions =
  Apollo.BaseMutationOptions<
    RequestPlayerSupervisionMutation,
    RequestPlayerSupervisionMutationVariables
  >;
export const ResolvePlayerSupervisionRequestDocument = gql`
  mutation ResolvePlayerSupervisionRequest(
    $input: ResolvePlayerSupervisionRequestInput!
  ) {
    resolvePlayerSupervisionRequest(input: $input)
  }
`;
export type ResolvePlayerSupervisionRequestMutationFn = Apollo.MutationFunction<
  ResolvePlayerSupervisionRequestMutation,
  ResolvePlayerSupervisionRequestMutationVariables
>;

/**
 * __useResolvePlayerSupervisionRequestMutation__
 *
 * To run a mutation, you first call `useResolvePlayerSupervisionRequestMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useResolvePlayerSupervisionRequestMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [resolvePlayerSupervisionRequestMutation, { data, loading, error }] = useResolvePlayerSupervisionRequestMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useResolvePlayerSupervisionRequestMutation(
  baseOptions?: Apollo.MutationHookOptions<
    ResolvePlayerSupervisionRequestMutation,
    ResolvePlayerSupervisionRequestMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useMutation<
    ResolvePlayerSupervisionRequestMutation,
    ResolvePlayerSupervisionRequestMutationVariables
  >(ResolvePlayerSupervisionRequestDocument, options);
}
export type ResolvePlayerSupervisionRequestMutationHookResult = ReturnType<
  typeof useResolvePlayerSupervisionRequestMutation
>;
export type ResolvePlayerSupervisionRequestMutationResult =
  Apollo.MutationResult<ResolvePlayerSupervisionRequestMutation>;
export type ResolvePlayerSupervisionRequestMutationOptions =
  Apollo.BaseMutationOptions<
    ResolvePlayerSupervisionRequestMutation,
    ResolvePlayerSupervisionRequestMutationVariables
  >;
export const UpdateUserDocument = gql`
  mutation UpdateUser($id: ID!, $input: UpdateUserInput!) {
    updateUser(id: $id, input: $input) {
      id
    }
  }
`;
export type UpdateUserMutationFn = Apollo.MutationFunction<
  UpdateUserMutation,
  UpdateUserMutationVariables
>;

/**
 * __useUpdateUserMutation__
 *
 * To run a mutation, you first call `useUpdateUserMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateUserMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateUserMutation, { data, loading, error }] = useUpdateUserMutation({
 *   variables: {
 *      id: // value for 'id'
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateUserMutation(
  baseOptions?: Apollo.MutationHookOptions<
    UpdateUserMutation,
    UpdateUserMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useMutation<UpdateUserMutation, UpdateUserMutationVariables>(
    UpdateUserDocument,
    options
  );
}
export type UpdateUserMutationHookResult = ReturnType<
  typeof useUpdateUserMutation
>;
export type UpdateUserMutationResult =
  Apollo.MutationResult<UpdateUserMutation>;
export type UpdateUserMutationOptions = Apollo.BaseMutationOptions<
  UpdateUserMutation,
  UpdateUserMutationVariables
>;
export const GetFileUploadUrlDocument = gql`
  query GetFileUploadURL {
    getFileUploadURL
  }
`;

/**
 * __useGetFileUploadUrlQuery__
 *
 * To run a query within a React component, call `useGetFileUploadUrlQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetFileUploadUrlQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetFileUploadUrlQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetFileUploadUrlQuery(
  baseOptions?: Apollo.QueryHookOptions<
    GetFileUploadUrlQuery,
    GetFileUploadUrlQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<GetFileUploadUrlQuery, GetFileUploadUrlQueryVariables>(
    GetFileUploadUrlDocument,
    options
  );
}
export function useGetFileUploadUrlLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetFileUploadUrlQuery,
    GetFileUploadUrlQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<
    GetFileUploadUrlQuery,
    GetFileUploadUrlQueryVariables
  >(GetFileUploadUrlDocument, options);
}
export type GetFileUploadUrlQueryHookResult = ReturnType<
  typeof useGetFileUploadUrlQuery
>;
export type GetFileUploadUrlLazyQueryHookResult = ReturnType<
  typeof useGetFileUploadUrlLazyQuery
>;
export type GetFileUploadUrlQueryResult = Apollo.QueryResult<
  GetFileUploadUrlQuery,
  GetFileUploadUrlQueryVariables
>;
export const GroupDocument = gql`
  query Group($id: ID!) {
    node(id: $id) {
      ...groupFields
    }
  }
  ${GroupFieldsFragmentDoc}
`;

/**
 * __useGroupQuery__
 *
 * To run a query within a React component, call `useGroupQuery` and pass it any options that fit your needs.
 * When your component renders, `useGroupQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGroupQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGroupQuery(
  baseOptions: Apollo.QueryHookOptions<GroupQuery, GroupQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<GroupQuery, GroupQueryVariables>(
    GroupDocument,
    options
  );
}
export function useGroupLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<GroupQuery, GroupQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<GroupQuery, GroupQueryVariables>(
    GroupDocument,
    options
  );
}
export type GroupQueryHookResult = ReturnType<typeof useGroupQuery>;
export type GroupLazyQueryHookResult = ReturnType<typeof useGroupLazyQuery>;
export type GroupQueryResult = Apollo.QueryResult<
  GroupQuery,
  GroupQueryVariables
>;
export const GroupMembersDocument = gql`
  query GroupMembers(
    $groupId: ID!
    $before: Cursor
    $after: Cursor
    $first: Int
    $last: Int
    $where: GroupMembershipWhereInput
  ) {
    node(id: $groupId) {
      ... on Group {
        members(
          before: $before
          after: $after
          first: $first
          last: $last
          where: $where
        ) {
          totalCount
          pageInfo {
            ...pageInfoFields
          }
          edges {
            node {
              id
              role
              user {
                ...userFields
              }
            }
          }
        }
      }
    }
  }
  ${PageInfoFieldsFragmentDoc}
  ${UserFieldsFragmentDoc}
`;

/**
 * __useGroupMembersQuery__
 *
 * To run a query within a React component, call `useGroupMembersQuery` and pass it any options that fit your needs.
 * When your component renders, `useGroupMembersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGroupMembersQuery({
 *   variables: {
 *      groupId: // value for 'groupId'
 *      before: // value for 'before'
 *      after: // value for 'after'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *      where: // value for 'where'
 *   },
 * });
 */
export function useGroupMembersQuery(
  baseOptions: Apollo.QueryHookOptions<
    GroupMembersQuery,
    GroupMembersQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<GroupMembersQuery, GroupMembersQueryVariables>(
    GroupMembersDocument,
    options
  );
}
export function useGroupMembersLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GroupMembersQuery,
    GroupMembersQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<GroupMembersQuery, GroupMembersQueryVariables>(
    GroupMembersDocument,
    options
  );
}
export type GroupMembersQueryHookResult = ReturnType<
  typeof useGroupMembersQuery
>;
export type GroupMembersLazyQueryHookResult = ReturnType<
  typeof useGroupMembersLazyQuery
>;
export type GroupMembersQueryResult = Apollo.QueryResult<
  GroupMembersQuery,
  GroupMembersQueryVariables
>;
export const GroupSettingsDocument = gql`
  query GroupSettings($id: ID!) {
    node(id: $id) {
      ... on Group {
        id
        name
        description
        logoURL
        settings {
          id
          visibility
          joinPolicy
          minimumRoleToInvite
        }
      }
    }
  }
`;

/**
 * __useGroupSettingsQuery__
 *
 * To run a query within a React component, call `useGroupSettingsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGroupSettingsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGroupSettingsQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGroupSettingsQuery(
  baseOptions: Apollo.QueryHookOptions<
    GroupSettingsQuery,
    GroupSettingsQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<GroupSettingsQuery, GroupSettingsQueryVariables>(
    GroupSettingsDocument,
    options
  );
}
export function useGroupSettingsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GroupSettingsQuery,
    GroupSettingsQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<GroupSettingsQuery, GroupSettingsQueryVariables>(
    GroupSettingsDocument,
    options
  );
}
export type GroupSettingsQueryHookResult = ReturnType<
  typeof useGroupSettingsQuery
>;
export type GroupSettingsLazyQueryHookResult = ReturnType<
  typeof useGroupSettingsLazyQuery
>;
export type GroupSettingsQueryResult = Apollo.QueryResult<
  GroupSettingsQuery,
  GroupSettingsQueryVariables
>;
export const IncomingSupervisionRequestsDocument = gql`
  query IncomingSupervisionRequests {
    me {
      receivedSupervisionRequests {
        ...playerSupervisionRequestFields
      }
    }
  }
  ${PlayerSupervisionRequestFieldsFragmentDoc}
`;

/**
 * __useIncomingSupervisionRequestsQuery__
 *
 * To run a query within a React component, call `useIncomingSupervisionRequestsQuery` and pass it any options that fit your needs.
 * When your component renders, `useIncomingSupervisionRequestsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useIncomingSupervisionRequestsQuery({
 *   variables: {
 *   },
 * });
 */
export function useIncomingSupervisionRequestsQuery(
  baseOptions?: Apollo.QueryHookOptions<
    IncomingSupervisionRequestsQuery,
    IncomingSupervisionRequestsQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<
    IncomingSupervisionRequestsQuery,
    IncomingSupervisionRequestsQueryVariables
  >(IncomingSupervisionRequestsDocument, options);
}
export function useIncomingSupervisionRequestsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    IncomingSupervisionRequestsQuery,
    IncomingSupervisionRequestsQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<
    IncomingSupervisionRequestsQuery,
    IncomingSupervisionRequestsQueryVariables
  >(IncomingSupervisionRequestsDocument, options);
}
export type IncomingSupervisionRequestsQueryHookResult = ReturnType<
  typeof useIncomingSupervisionRequestsQuery
>;
export type IncomingSupervisionRequestsLazyQueryHookResult = ReturnType<
  typeof useIncomingSupervisionRequestsLazyQuery
>;
export type IncomingSupervisionRequestsQueryResult = Apollo.QueryResult<
  IncomingSupervisionRequestsQuery,
  IncomingSupervisionRequestsQueryVariables
>;
export const MeDocument = gql`
  query Me {
    me {
      ...userFields
    }
  }
  ${UserFieldsFragmentDoc}
`;

/**
 * __useMeQuery__
 *
 * To run a query within a React component, call `useMeQuery` and pass it any options that fit your needs.
 * When your component renders, `useMeQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMeQuery({
 *   variables: {
 *   },
 * });
 */
export function useMeQuery(
  baseOptions?: Apollo.QueryHookOptions<MeQuery, MeQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<MeQuery, MeQueryVariables>(MeDocument, options);
}
export function useMeLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<MeQuery, MeQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<MeQuery, MeQueryVariables>(MeDocument, options);
}
export type MeQueryHookResult = ReturnType<typeof useMeQuery>;
export type MeLazyQueryHookResult = ReturnType<typeof useMeLazyQuery>;
export type MeQueryResult = Apollo.QueryResult<MeQuery, MeQueryVariables>;
export const MyPlayersDocument = gql`
  query MyPlayers {
    me {
      players {
        ...playerFields
      }
    }
  }
  ${PlayerFieldsFragmentDoc}
`;

/**
 * __useMyPlayersQuery__
 *
 * To run a query within a React component, call `useMyPlayersQuery` and pass it any options that fit your needs.
 * When your component renders, `useMyPlayersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMyPlayersQuery({
 *   variables: {
 *   },
 * });
 */
export function useMyPlayersQuery(
  baseOptions?: Apollo.QueryHookOptions<MyPlayersQuery, MyPlayersQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<MyPlayersQuery, MyPlayersQueryVariables>(
    MyPlayersDocument,
    options
  );
}
export function useMyPlayersLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    MyPlayersQuery,
    MyPlayersQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<MyPlayersQuery, MyPlayersQueryVariables>(
    MyPlayersDocument,
    options
  );
}
export type MyPlayersQueryHookResult = ReturnType<typeof useMyPlayersQuery>;
export type MyPlayersLazyQueryHookResult = ReturnType<
  typeof useMyPlayersLazyQuery
>;
export type MyPlayersQueryResult = Apollo.QueryResult<
  MyPlayersQuery,
  MyPlayersQueryVariables
>;
export const PendingSupervisionRequestsDocument = gql`
  query PendingSupervisionRequests {
    me {
      sentSupervisionRequests {
        ...playerSupervisionRequestFields
      }
    }
  }
  ${PlayerSupervisionRequestFieldsFragmentDoc}
`;

/**
 * __usePendingSupervisionRequestsQuery__
 *
 * To run a query within a React component, call `usePendingSupervisionRequestsQuery` and pass it any options that fit your needs.
 * When your component renders, `usePendingSupervisionRequestsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePendingSupervisionRequestsQuery({
 *   variables: {
 *   },
 * });
 */
export function usePendingSupervisionRequestsQuery(
  baseOptions?: Apollo.QueryHookOptions<
    PendingSupervisionRequestsQuery,
    PendingSupervisionRequestsQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<
    PendingSupervisionRequestsQuery,
    PendingSupervisionRequestsQueryVariables
  >(PendingSupervisionRequestsDocument, options);
}
export function usePendingSupervisionRequestsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    PendingSupervisionRequestsQuery,
    PendingSupervisionRequestsQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<
    PendingSupervisionRequestsQuery,
    PendingSupervisionRequestsQueryVariables
  >(PendingSupervisionRequestsDocument, options);
}
export type PendingSupervisionRequestsQueryHookResult = ReturnType<
  typeof usePendingSupervisionRequestsQuery
>;
export type PendingSupervisionRequestsLazyQueryHookResult = ReturnType<
  typeof usePendingSupervisionRequestsLazyQuery
>;
export type PendingSupervisionRequestsQueryResult = Apollo.QueryResult<
  PendingSupervisionRequestsQuery,
  PendingSupervisionRequestsQueryVariables
>;
export const SearchGroupsDocument = gql`
  query SearchGroups(
    $before: Cursor
    $after: Cursor
    $where: GroupWhereInput!
    $first: Int
    $last: Int
  ) {
    groups(
      before: $before
      after: $after
      where: $where
      first: $first
      last: $last
    ) {
      pageInfo {
        ...pageInfoFields
      }
      totalCount
      edges {
        node {
          ...groupFields
        }
      }
    }
  }
  ${PageInfoFieldsFragmentDoc}
  ${GroupFieldsFragmentDoc}
`;

/**
 * __useSearchGroupsQuery__
 *
 * To run a query within a React component, call `useSearchGroupsQuery` and pass it any options that fit your needs.
 * When your component renders, `useSearchGroupsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSearchGroupsQuery({
 *   variables: {
 *      before: // value for 'before'
 *      after: // value for 'after'
 *      where: // value for 'where'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useSearchGroupsQuery(
  baseOptions: Apollo.QueryHookOptions<
    SearchGroupsQuery,
    SearchGroupsQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<SearchGroupsQuery, SearchGroupsQueryVariables>(
    SearchGroupsDocument,
    options
  );
}
export function useSearchGroupsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    SearchGroupsQuery,
    SearchGroupsQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<SearchGroupsQuery, SearchGroupsQueryVariables>(
    SearchGroupsDocument,
    options
  );
}
export type SearchGroupsQueryHookResult = ReturnType<
  typeof useSearchGroupsQuery
>;
export type SearchGroupsLazyQueryHookResult = ReturnType<
  typeof useSearchGroupsLazyQuery
>;
export type SearchGroupsQueryResult = Apollo.QueryResult<
  SearchGroupsQuery,
  SearchGroupsQueryVariables
>;
export const SearchPlayersDocument = gql`
  query SearchPlayers(
    $before: Cursor
    $after: Cursor
    $where: PlayerWhereInput!
    $first: Int
    $last: Int
  ) {
    players(
      before: $before
      after: $after
      where: $where
      first: $first
      last: $last
    ) {
      pageInfo {
        ...pageInfoFields
      }
      totalCount
      edges {
        cursor
        node {
          ...playerFields
        }
      }
    }
  }
  ${PageInfoFieldsFragmentDoc}
  ${PlayerFieldsFragmentDoc}
`;

/**
 * __useSearchPlayersQuery__
 *
 * To run a query within a React component, call `useSearchPlayersQuery` and pass it any options that fit your needs.
 * When your component renders, `useSearchPlayersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSearchPlayersQuery({
 *   variables: {
 *      before: // value for 'before'
 *      after: // value for 'after'
 *      where: // value for 'where'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useSearchPlayersQuery(
  baseOptions: Apollo.QueryHookOptions<
    SearchPlayersQuery,
    SearchPlayersQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<SearchPlayersQuery, SearchPlayersQueryVariables>(
    SearchPlayersDocument,
    options
  );
}
export function useSearchPlayersLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    SearchPlayersQuery,
    SearchPlayersQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<SearchPlayersQuery, SearchPlayersQueryVariables>(
    SearchPlayersDocument,
    options
  );
}
export type SearchPlayersQueryHookResult = ReturnType<
  typeof useSearchPlayersQuery
>;
export type SearchPlayersLazyQueryHookResult = ReturnType<
  typeof useSearchPlayersLazyQuery
>;
export type SearchPlayersQueryResult = Apollo.QueryResult<
  SearchPlayersQuery,
  SearchPlayersQueryVariables
>;
export type WithIndex<TObject> = TObject & Record<string, any>;
export type ResolversObject<TObject> = WithIndex<TObject>;

export type ResolverTypeWrapper<T> = Promise<T> | T;

export type ResolverWithResolve<TResult, TParent, TContext, TArgs> = {
  resolve: ResolverFn<TResult, TParent, TContext, TArgs>;
};
export type Resolver<TResult, TParent = {}, TContext = {}, TArgs = {}> =
  | ResolverFn<TResult, TParent, TContext, TArgs>
  | ResolverWithResolve<TResult, TParent, TContext, TArgs>;

export type ResolverFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => Promise<TResult> | TResult;

export type SubscriptionSubscribeFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => AsyncIterable<TResult> | Promise<AsyncIterable<TResult>>;

export type SubscriptionResolveFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => TResult | Promise<TResult>;

export interface SubscriptionSubscriberObject<
  TResult,
  TKey extends string,
  TParent,
  TContext,
  TArgs
> {
  subscribe: SubscriptionSubscribeFn<
    { [key in TKey]: TResult },
    TParent,
    TContext,
    TArgs
  >;
  resolve?: SubscriptionResolveFn<
    TResult,
    { [key in TKey]: TResult },
    TContext,
    TArgs
  >;
}

export interface SubscriptionResolverObject<TResult, TParent, TContext, TArgs> {
  subscribe: SubscriptionSubscribeFn<any, TParent, TContext, TArgs>;
  resolve: SubscriptionResolveFn<TResult, any, TContext, TArgs>;
}

export type SubscriptionObject<
  TResult,
  TKey extends string,
  TParent,
  TContext,
  TArgs
> =
  | SubscriptionSubscriberObject<TResult, TKey, TParent, TContext, TArgs>
  | SubscriptionResolverObject<TResult, TParent, TContext, TArgs>;

export type SubscriptionResolver<
  TResult,
  TKey extends string,
  TParent = {},
  TContext = {},
  TArgs = {}
> =
  | ((
      ...args: any[]
    ) => SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>)
  | SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>;

export type TypeResolveFn<TTypes, TParent = {}, TContext = {}> = (
  parent: TParent,
  context: TContext,
  info: GraphQLResolveInfo
) => Maybe<TTypes> | Promise<Maybe<TTypes>>;

export type IsTypeOfResolverFn<T = {}, TContext = {}> = (
  obj: T,
  context: TContext,
  info: GraphQLResolveInfo
) => boolean | Promise<boolean>;

export type NextResolverFn<T> = () => Promise<T>;

export type DirectiveResolverFn<
  TResult = {},
  TParent = {},
  TContext = {},
  TArgs = {}
> = (
  next: NextResolverFn<TResult>,
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => TResult | Promise<TResult>;

/** Mapping between all available schema types and the resolvers types */
export type ResolversTypes = ResolversObject<{
  Boolean: ResolverTypeWrapper<Scalars["Boolean"]>;
  CreateOrUpdateGroupInput: CreateOrUpdateGroupInput;
  CreatePlayerInput: CreatePlayerInput;
  Cursor: ResolverTypeWrapper<Scalars["Cursor"]>;
  Float: ResolverTypeWrapper<Scalars["Float"]>;
  Group: ResolverTypeWrapper<Group>;
  GroupApplicationInput: GroupApplicationInput;
  GroupConnection: ResolverTypeWrapper<GroupConnection>;
  GroupEdge: ResolverTypeWrapper<GroupEdge>;
  GroupMembership: ResolverTypeWrapper<GroupMembership>;
  GroupMembershipApplication: ResolverTypeWrapper<GroupMembershipApplication>;
  GroupMembershipConnection: ResolverTypeWrapper<GroupMembershipConnection>;
  GroupMembershipEdge: ResolverTypeWrapper<GroupMembershipEdge>;
  GroupMembershipRole: GroupMembershipRole;
  GroupMembershipWhereInput: GroupMembershipWhereInput;
  GroupSettings: ResolverTypeWrapper<GroupSettings>;
  GroupSettingsInput: GroupSettingsInput;
  GroupSettingsJoinPolicy: GroupSettingsJoinPolicy;
  GroupSettingsVisibility: GroupSettingsVisibility;
  GroupSettingsWhereInput: GroupSettingsWhereInput;
  GroupWhereInput: GroupWhereInput;
  ID: ResolverTypeWrapper<Scalars["ID"]>;
  Int: ResolverTypeWrapper<Scalars["Int"]>;
  Mutation: ResolverTypeWrapper<{}>;
  Node:
    | ResolversTypes["Group"]
    | ResolversTypes["GroupMembership"]
    | ResolversTypes["GroupMembershipApplication"]
    | ResolversTypes["GroupSettings"]
    | ResolversTypes["Player"]
    | ResolversTypes["PlayerSupervisionRequest"]
    | ResolversTypes["PlayerSupervisionRequestApproval"]
    | ResolversTypes["User"];
  OrderDirection: OrderDirection;
  PageInfo: ResolverTypeWrapper<PageInfo>;
  Player: ResolverTypeWrapper<Player>;
  PlayerConnection: ResolverTypeWrapper<PlayerConnection>;
  PlayerEdge: ResolverTypeWrapper<PlayerEdge>;
  PlayerSupervisionRequest: ResolverTypeWrapper<PlayerSupervisionRequest>;
  PlayerSupervisionRequestApproval: ResolverTypeWrapper<PlayerSupervisionRequestApproval>;
  PlayerSupervisionRequestApprovalWhereInput: PlayerSupervisionRequestApprovalWhereInput;
  PlayerSupervisionRequestWhereInput: PlayerSupervisionRequestWhereInput;
  PlayerWhereInput: PlayerWhereInput;
  Query: ResolverTypeWrapper<{}>;
  RequestPlayerSupervisionInput: RequestPlayerSupervisionInput;
  ResolvePlayerSupervisionRequestInput: ResolvePlayerSupervisionRequestInput;
  String: ResolverTypeWrapper<Scalars["String"]>;
  UpdateUserInput: UpdateUserInput;
  User: ResolverTypeWrapper<User>;
  UserConnection: ResolverTypeWrapper<UserConnection>;
  UserEdge: ResolverTypeWrapper<UserEdge>;
  UserWhereInput: UserWhereInput;
}>;

/** Mapping between all available schema types and the resolvers parents */
export type ResolversParentTypes = ResolversObject<{
  Boolean: Scalars["Boolean"];
  CreateOrUpdateGroupInput: CreateOrUpdateGroupInput;
  CreatePlayerInput: CreatePlayerInput;
  Cursor: Scalars["Cursor"];
  Float: Scalars["Float"];
  Group: Group;
  GroupApplicationInput: GroupApplicationInput;
  GroupConnection: GroupConnection;
  GroupEdge: GroupEdge;
  GroupMembership: GroupMembership;
  GroupMembershipApplication: GroupMembershipApplication;
  GroupMembershipConnection: GroupMembershipConnection;
  GroupMembershipEdge: GroupMembershipEdge;
  GroupMembershipWhereInput: GroupMembershipWhereInput;
  GroupSettings: GroupSettings;
  GroupSettingsInput: GroupSettingsInput;
  GroupSettingsWhereInput: GroupSettingsWhereInput;
  GroupWhereInput: GroupWhereInput;
  ID: Scalars["ID"];
  Int: Scalars["Int"];
  Mutation: {};
  Node:
    | ResolversParentTypes["Group"]
    | ResolversParentTypes["GroupMembership"]
    | ResolversParentTypes["GroupMembershipApplication"]
    | ResolversParentTypes["GroupSettings"]
    | ResolversParentTypes["Player"]
    | ResolversParentTypes["PlayerSupervisionRequest"]
    | ResolversParentTypes["PlayerSupervisionRequestApproval"]
    | ResolversParentTypes["User"];
  PageInfo: PageInfo;
  Player: Player;
  PlayerConnection: PlayerConnection;
  PlayerEdge: PlayerEdge;
  PlayerSupervisionRequest: PlayerSupervisionRequest;
  PlayerSupervisionRequestApproval: PlayerSupervisionRequestApproval;
  PlayerSupervisionRequestApprovalWhereInput: PlayerSupervisionRequestApprovalWhereInput;
  PlayerSupervisionRequestWhereInput: PlayerSupervisionRequestWhereInput;
  PlayerWhereInput: PlayerWhereInput;
  Query: {};
  RequestPlayerSupervisionInput: RequestPlayerSupervisionInput;
  ResolvePlayerSupervisionRequestInput: ResolvePlayerSupervisionRequestInput;
  String: Scalars["String"];
  UpdateUserInput: UpdateUserInput;
  User: User;
  UserConnection: UserConnection;
  UserEdge: UserEdge;
  UserWhereInput: UserWhereInput;
}>;

export type AuthenticatedDirectiveArgs = {};

export type AuthenticatedDirectiveResolver<
  Result,
  Parent,
  ContextType = any,
  Args = AuthenticatedDirectiveArgs
> = DirectiveResolverFn<Result, Parent, ContextType, Args>;

export type GoFieldDirectiveArgs = {
  forceResolver?: Maybe<Scalars["Boolean"]>;
  name?: Maybe<Scalars["String"]>;
};

export type GoFieldDirectiveResolver<
  Result,
  Parent,
  ContextType = any,
  Args = GoFieldDirectiveArgs
> = DirectiveResolverFn<Result, Parent, ContextType, Args>;

export type GoModelDirectiveArgs = {
  model?: Maybe<Scalars["String"]>;
  models?: Maybe<Array<Scalars["String"]>>;
};

export type GoModelDirectiveResolver<
  Result,
  Parent,
  ContextType = any,
  Args = GoModelDirectiveArgs
> = DirectiveResolverFn<Result, Parent, ContextType, Args>;

export interface CursorScalarConfig
  extends GraphQLScalarTypeConfig<ResolversTypes["Cursor"], any> {
  name: "Cursor";
}

export type GroupResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["Group"] = ResolversParentTypes["Group"]
> = ResolversObject<{
  applications?: Resolver<
    Maybe<Array<ResolversTypes["GroupMembershipApplication"]>>,
    ParentType,
    ContextType
  >;
  applied?: Resolver<Maybe<ResolversTypes["Boolean"]>, ParentType, ContextType>;
  description?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  logoURL?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  members?: Resolver<
    ResolversTypes["GroupMembershipConnection"],
    ParentType,
    ContextType,
    Partial<GroupMembersArgs>
  >;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  role?: Resolver<
    Maybe<ResolversTypes["GroupMembershipRole"]>,
    ParentType,
    ContextType
  >;
  settings?: Resolver<ResolversTypes["GroupSettings"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GroupConnectionResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["GroupConnection"] = ResolversParentTypes["GroupConnection"]
> = ResolversObject<{
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["GroupEdge"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GroupEdgeResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["GroupEdge"] = ResolversParentTypes["GroupEdge"]
> = ResolversObject<{
  cursor?: Resolver<ResolversTypes["Cursor"], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes["Group"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GroupMembershipResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["GroupMembership"] = ResolversParentTypes["GroupMembership"]
> = ResolversObject<{
  group?: Resolver<ResolversTypes["Group"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  role?: Resolver<
    ResolversTypes["GroupMembershipRole"],
    ParentType,
    ContextType
  >;
  user?: Resolver<ResolversTypes["User"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GroupMembershipApplicationResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["GroupMembershipApplication"] = ResolversParentTypes["GroupMembershipApplication"]
> = ResolversObject<{
  group?: Resolver<Array<ResolversTypes["Group"]>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  message?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  user?: Resolver<Array<ResolversTypes["User"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GroupMembershipConnectionResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["GroupMembershipConnection"] = ResolversParentTypes["GroupMembershipConnection"]
> = ResolversObject<{
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["GroupMembershipEdge"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GroupMembershipEdgeResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["GroupMembershipEdge"] = ResolversParentTypes["GroupMembershipEdge"]
> = ResolversObject<{
  cursor?: Resolver<ResolversTypes["Cursor"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["GroupMembership"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GroupSettingsResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["GroupSettings"] = ResolversParentTypes["GroupSettings"]
> = ResolversObject<{
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  joinPolicy?: Resolver<
    ResolversTypes["GroupSettingsJoinPolicy"],
    ParentType,
    ContextType
  >;
  minimumRoleToInvite?: Resolver<
    Maybe<ResolversTypes["GroupMembershipRole"]>,
    ParentType,
    ContextType
  >;
  visibility?: Resolver<
    ResolversTypes["GroupSettingsVisibility"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type MutationResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["Mutation"] = ResolversParentTypes["Mutation"]
> = ResolversObject<{
  applyToGroup?: Resolver<
    ResolversTypes["GroupMembershipApplication"],
    ParentType,
    ContextType,
    RequireFields<MutationApplyToGroupArgs, "input">
  >;
  createOrUpdateGroup?: Resolver<
    ResolversTypes["Group"],
    ParentType,
    ContextType,
    RequireFields<MutationCreateOrUpdateGroupArgs, "input">
  >;
  createPlayer?: Resolver<
    ResolversTypes["Player"],
    ParentType,
    ContextType,
    RequireFields<MutationCreatePlayerArgs, "input">
  >;
  joinGroup?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType,
    RequireFields<MutationJoinGroupArgs, "groupId">
  >;
  requestPlayerSupervision?: Resolver<
    ResolversTypes["PlayerSupervisionRequest"],
    ParentType,
    ContextType,
    Partial<MutationRequestPlayerSupervisionArgs>
  >;
  resolvePlayerSupervisionRequest?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType,
    RequireFields<MutationResolvePlayerSupervisionRequestArgs, "input">
  >;
  updateUser?: Resolver<
    ResolversTypes["User"],
    ParentType,
    ContextType,
    RequireFields<MutationUpdateUserArgs, "id" | "input">
  >;
}>;

export type NodeResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["Node"] = ResolversParentTypes["Node"]
> = ResolversObject<{
  __resolveType: TypeResolveFn<
    | "Group"
    | "GroupMembership"
    | "GroupMembershipApplication"
    | "GroupSettings"
    | "Player"
    | "PlayerSupervisionRequest"
    | "PlayerSupervisionRequestApproval"
    | "User",
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
}>;

export type PageInfoResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["PageInfo"] = ResolversParentTypes["PageInfo"]
> = ResolversObject<{
  endCursor?: Resolver<
    Maybe<ResolversTypes["Cursor"]>,
    ParentType,
    ContextType
  >;
  hasNextPage?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  hasPreviousPage?: Resolver<
    ResolversTypes["Boolean"],
    ParentType,
    ContextType
  >;
  startCursor?: Resolver<
    Maybe<ResolversTypes["Cursor"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PlayerResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["Player"] = ResolversParentTypes["Player"]
> = ResolversObject<{
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  owner?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  supervisionRequests?: Resolver<
    Maybe<Array<ResolversTypes["PlayerSupervisionRequest"]>>,
    ParentType,
    ContextType
  >;
  supervisors?: Resolver<
    Maybe<Array<ResolversTypes["User"]>>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PlayerConnectionResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["PlayerConnection"] = ResolversParentTypes["PlayerConnection"]
> = ResolversObject<{
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["PlayerEdge"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PlayerEdgeResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["PlayerEdge"] = ResolversParentTypes["PlayerEdge"]
> = ResolversObject<{
  cursor?: Resolver<ResolversTypes["Cursor"], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes["Player"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PlayerSupervisionRequestResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["PlayerSupervisionRequest"] = ResolversParentTypes["PlayerSupervisionRequest"]
> = ResolversObject<{
  approvals?: Resolver<
    Maybe<Array<ResolversTypes["PlayerSupervisionRequestApproval"]>>,
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  player?: Resolver<ResolversTypes["Player"], ParentType, ContextType>;
  sender?: Resolver<ResolversTypes["User"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type PlayerSupervisionRequestApprovalResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["PlayerSupervisionRequestApproval"] = ResolversParentTypes["PlayerSupervisionRequestApproval"]
> = ResolversObject<{
  approved?: Resolver<
    Maybe<ResolversTypes["Boolean"]>,
    ParentType,
    ContextType
  >;
  approver?: Resolver<ResolversTypes["User"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  supervisionRequest?: Resolver<
    ResolversTypes["PlayerSupervisionRequest"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type QueryResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["Query"] = ResolversParentTypes["Query"]
> = ResolversObject<{
  getFileUploadURL?: Resolver<
    ResolversTypes["String"],
    ParentType,
    ContextType
  >;
  groups?: Resolver<
    ResolversTypes["GroupConnection"],
    ParentType,
    ContextType,
    Partial<QueryGroupsArgs>
  >;
  me?: Resolver<ResolversTypes["User"], ParentType, ContextType>;
  node?: Resolver<
    Maybe<ResolversTypes["Node"]>,
    ParentType,
    ContextType,
    RequireFields<QueryNodeArgs, "id">
  >;
  nodes?: Resolver<
    Array<Maybe<ResolversTypes["Node"]>>,
    ParentType,
    ContextType,
    RequireFields<QueryNodesArgs, "ids">
  >;
  players?: Resolver<
    ResolversTypes["PlayerConnection"],
    ParentType,
    ContextType,
    Partial<QueryPlayersArgs>
  >;
  users?: Resolver<
    ResolversTypes["UserConnection"],
    ParentType,
    ContextType,
    Partial<QueryUsersArgs>
  >;
}>;

export type UserResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["User"] = ResolversParentTypes["User"]
> = ResolversObject<{
  avatarURL?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  email?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  groupMembershipApplications?: Resolver<
    Maybe<Array<ResolversTypes["GroupMembershipApplication"]>>,
    ParentType,
    ContextType
  >;
  groupMemberships?: Resolver<
    Maybe<Array<ResolversTypes["GroupMembership"]>>,
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  mainPlayer?: Resolver<
    Maybe<ResolversTypes["Player"]>,
    ParentType,
    ContextType
  >;
  name?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  players?: Resolver<
    Maybe<Array<ResolversTypes["Player"]>>,
    ParentType,
    ContextType
  >;
  receivedSupervisionRequests?: Resolver<
    Array<ResolversTypes["PlayerSupervisionRequest"]>,
    ParentType,
    ContextType
  >;
  sentSupervisionRequests?: Resolver<
    Array<ResolversTypes["PlayerSupervisionRequest"]>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UserConnectionResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["UserConnection"] = ResolversParentTypes["UserConnection"]
> = ResolversObject<{
  edges?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["UserEdge"]>>>,
    ParentType,
    ContextType
  >;
  pageInfo?: Resolver<ResolversTypes["PageInfo"], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UserEdgeResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["UserEdge"] = ResolversParentTypes["UserEdge"]
> = ResolversObject<{
  cursor?: Resolver<ResolversTypes["Cursor"], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Resolvers<ContextType = any> = ResolversObject<{
  Cursor?: GraphQLScalarType;
  Group?: GroupResolvers<ContextType>;
  GroupConnection?: GroupConnectionResolvers<ContextType>;
  GroupEdge?: GroupEdgeResolvers<ContextType>;
  GroupMembership?: GroupMembershipResolvers<ContextType>;
  GroupMembershipApplication?: GroupMembershipApplicationResolvers<ContextType>;
  GroupMembershipConnection?: GroupMembershipConnectionResolvers<ContextType>;
  GroupMembershipEdge?: GroupMembershipEdgeResolvers<ContextType>;
  GroupSettings?: GroupSettingsResolvers<ContextType>;
  Mutation?: MutationResolvers<ContextType>;
  Node?: NodeResolvers<ContextType>;
  PageInfo?: PageInfoResolvers<ContextType>;
  Player?: PlayerResolvers<ContextType>;
  PlayerConnection?: PlayerConnectionResolvers<ContextType>;
  PlayerEdge?: PlayerEdgeResolvers<ContextType>;
  PlayerSupervisionRequest?: PlayerSupervisionRequestResolvers<ContextType>;
  PlayerSupervisionRequestApproval?: PlayerSupervisionRequestApprovalResolvers<ContextType>;
  Query?: QueryResolvers<ContextType>;
  User?: UserResolvers<ContextType>;
  UserConnection?: UserConnectionResolvers<ContextType>;
  UserEdge?: UserEdgeResolvers<ContextType>;
}>;

export type DirectiveResolvers<ContextType = any> = ResolversObject<{
  authenticated?: AuthenticatedDirectiveResolver<any, any, ContextType>;
  goField?: GoFieldDirectiveResolver<any, any, ContextType>;
  goModel?: GoModelDirectiveResolver<any, any, ContextType>;
}>;
